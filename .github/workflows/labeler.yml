name: PR Labeler

permissions:
  contents: read
  issues: write
  pull-requests: write

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const branch = context.payload.pull_request.head.ref;
            const labels = new Set();

            // Type by prefix
            if (branch.startsWith('feat/')) labels.add('type: feature');
            if (branch.startsWith('fix/')) labels.add('type: fix');
            if (branch.startsWith('chore/')) labels.add('type: chore');

            // Area by path fragment
            if (branch.includes('cad-core')) labels.add('area: cad-core');
            if (branch.includes('backend')) labels.add('area: backend');
            if (branch.includes('frontend')) labels.add('area: frontend');
            if (branch.includes('qa')) labels.add('area: qa');
            if (branch.includes('integration')) labels.add('area: integration');

            // Ensure labels exist
            for (const name of labels) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name,
                });
              } catch (e) {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name,
                  color: 'ededed',
                });
              }
            }

            if (labels.size) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: [...labels],
              });
            }
