import json
from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtCore import Qt, QPointF, QSize
from PySide6.QtWidgets import (QApplication, QMainWindow, QWidget, QHBoxLayout, QVBoxLayout,
    QLabel, QToolBar, QGraphicsView, QMenu, QCheckBox)

from app.scene import GridScene, DEFAULT_GRID_SIZE
from app.tools import draw as draw_tools
from app.tools.dimension import DimensionTool

APP_VERSION = "0.6.0-corecad"
APP_TITLE   = f"Auto-Fire {APP_VERSION}"

def ft_to_px(ft: float, px_per_ft: float) -> float: return ft*px_per_ft
def px_to_ft(px: float, px_per_ft: float) -> float: return px/px_per_ft
def fmt_ft_inches(ft: float) -> str:
    sign = '-' if ft < 0 else ''
    ft = abs(ft); whole = int(ft); inches = (ft - whole)*12.0
    return f"{sign}{whole}'-{inches:.1f}\""

class CanvasView(QGraphicsView):
    def __init__(self, scene, sketch_group, overlay_group, window_ref):
        super().__init__(scene)
        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.TextAntialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setMouseTracking(True)
        self.sketch_group = sketch_group
        self.overlay_group = overlay_group
        self.ortho = False
        self.win = window_ref

        # crosshair
        self.cross_v = QtWidgets.QGraphicsLineItem(); self.cross_h = QtWidgets.QGraphicsLineItem()
        pen = QtGui.QPen(QtGui.QColor(130,130,130,160)); pen.setCosmetic(True); pen.setStyle(Qt.DashLine)
        for ln in (self.cross_v,self.cross_h): ln.setPen(pen); ln.setZValue(500); scene.addItem(ln)
        self.show_crosshair = True

    def _update_cross(self, sp: QPointF):
        if not self.show_crosshair: return
        r = self.scene().sceneRect()
        self.cross_v.setLine(sp.x(), r.top(), sp.x(), r.bottom())
        self.cross_h.setLine(r.left(), sp.y(), r.right(), sp.y())
        xft = px_to_ft(sp.x(), self.win.px_per_ft); yft = px_to_ft(sp.y(), self.win.px_per_ft)
        self.win.statusBar().showMessage(f"x={fmt_ft_inches(xft)}  y={fmt_ft_inches(yft)}  scale={self.win.px_per_ft:.2f} px/ft  snap={self.win.snap_label}")

    def wheelEvent(self, e: QtGui.QWheelEvent):
        s = 1.15 if e.angleDelta().y()>0 else 1/1.15
        self.scale(s, s)

    def keyPressEvent(self, e: QtGui.QKeyEvent):
        if e.key()==Qt.Key_Shift: self.ortho=True; e.accept(); return
        if e.key()==Qt.Key_C: self.show_crosshair = not self.show_crosshair; e.accept(); return
        if e.key()==Qt.Key_Escape and getattr(self.win, "draw", None): self.win.draw.finish(); e.accept(); return
        super().keyPressEvent(e)

    def keyReleaseEvent(self, e: QtGui.QKeyEvent):
        if e.key()==Qt.Key_Shift: self.ortho=False; e.accept(); return
        super().keyReleaseEvent(e)

    def mouseMoveEvent(self, e: QtGui.QMouseEvent):
        sp = self.mapToScene(e.position().toPoint())
        self._update_cross(sp)
        if getattr(self.win, "draw", None): self.win.draw.on_mouse_move(sp, shift_ortho=self.ortho)
        if getattr(self.win, "dim_tool", None): self.win.dim_tool.on_mouse_move(sp)
        super().mouseMoveEvent(e)

    def mousePressEvent(self, e: QtGui.QMouseEvent):
        sp = self.scene().snap(self.mapToScene(e.position().toPoint()))
        if e.button()==Qt.LeftButton:
            if getattr(self.win, "draw", None) and self.win.draw.mode != draw_tools.DrawMode.NONE:
                if self.win.draw.on_click(sp, shift_ortho=self.ortho): self.win.push_history(); e.accept(); return
            if getattr(self.win, "dim_tool", None) and self.win.dim_tool.active:
                if self.win.dim_tool.on_click(sp): e.accept(); return
        elif e.button()==Qt.RightButton:
            self.win.canvas_menu(e.globalPosition().toPoint()); e.accept(); return
        super().mousePressEvent(e)

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(APP_TITLE); self.resize(1400, 900)
        self.px_per_ft = 12.0
        self.snap_label = "grid"

        # dark theme
        pal = self.palette()
        pal.setColor(pal.Window, QtGui.QColor(32,32,36))
        pal.setColor(pal.Base,   QtGui.QColor(26,26,28))
        pal.setColor(pal.Text,   QtCore.Qt.white); pal.setColor(pal.WindowText, QtCore.Qt.white)
        pal.setColor(pal.Button, QtGui.QColor(48,48,52)); pal.setColor(pal.ButtonText, QtCore.Qt.white)
        self.setPalette(pal)

        self.scene = GridScene(DEFAULT_GRID_SIZE, 0,0,12000,9000)
        self.scene.snap_enabled = True
        self.scene.setSceneRect(0,0,12000,9000)

        # layers
        self.layer_underlay = QtWidgets.QGraphicsItemGroup(); self.layer_underlay.setZValue(-10); self.scene.addItem(self.layer_underlay)
        self.layer_sketch   = QtWidgets.QGraphicsItemGroup(); self.layer_sketch.setZValue(40);   self.scene.addItem(self.layer_sketch)
        self.layer_overlay  = QtWidgets.QGraphicsItemGroup(); self.layer_overlay.setZValue(200); self.scene.addItem(self.layer_overlay)

        self.view = CanvasView(self.scene, self.layer_sketch, self.layer_overlay, self)

        # controllers
        self.draw = draw_tools.DrawController(self, self.layer_sketch)
        self.dim_tool = DimensionTool(self, self.layer_overlay)

        # UI — toolbar
        tb = QToolBar("Main"); tb.setIconSize(QSize(16,16)); self.addToolBar(tb)
        act_line   = QtGui.QAction("Line", self, triggered=lambda: self.draw.set_mode(draw_tools.DrawMode.LINE))
        act_rect   = QtGui.QAction("Rect", self, triggered=lambda: self.draw.set_mode(draw_tools.DrawMode.RECT))
        act_circle = QtGui.QAction("Circle", self, triggered=lambda: self.draw.set_mode(draw_tools.DrawMode.CIRCLE))
        act_poly   = QtGui.QAction("Polyline", self, triggered=lambda: self.draw.set_mode(draw_tools.DrawMode.POLYLINE))
        act_dim    = QtGui.QAction("Dimension", self, triggered=self.start_dimension)
        act_fit    = QtGui.QAction("Fit (F2)", self, triggered=self.fit_view_to_content)
        tb.addActions([act_line, act_rect, act_circle, act_poly]); tb.addSeparator(); tb.addAction(act_dim); tb.addSeparator(); tb.addAction(act_fit)

        # grid/snap panel
        pnl = QWidget(); pv = QHBoxLayout(pnl)
        pv.addWidget(QLabel("Grid(px):"))
        self.chk_grid = QCheckBox("Show Grid"); self.chk_grid.setChecked(True); self.chk_grid.toggled.connect(self.toggle_grid); pv.addWidget(self.chk_grid)
        self.chk_snap = QCheckBox("Snap"); self.chk_snap.setChecked(self.scene.snap_enabled); self.chk_snap.toggled.connect(self.toggle_snap); pv.addWidget(self.chk_snap)
        self.lbl_scale = QLabel("px/ft: 12.0"); pv.addWidget(self.lbl_scale)
        tb.addWidget(pnl)

        # menu
        menubar = self.menuBar()
        m_view = menubar.addMenu("&View")
        m_view.addAction("Set Pixels per Foot…", self.set_px_per_ft)
        m_snap = m_view.addMenu("Snap step")
        for name, inches in [("Grid intersections (default)", 0.0), ('6\"', 6.0), ('12\"',12.0), ('24\"',24.0)]:
            a = QtGui.QAction(name, self, checkable=True)
            a.triggered.connect(lambda _=False, inc=inches: self.set_snap_inches(inc))
            m_snap.addAction(a)
        QtGui.QShortcut(QtGui.QKeySequence("F2"), self, activated=self.fit_view_to_content)

        # layout
        container = QWidget(); lay = QHBoxLayout(container); lay.addWidget(self.view); self.setCentralWidget(container)
        self.statusBar().showMessage("Ready")
        self.history = []; self.history_index = -1
        self.push_history()

    # view toggles
    def toggle_grid(self, on: bool): self.scene.show_grid = bool(on); self.scene.update()
    def toggle_snap(self, on: bool): self.scene.snap_enabled = bool(on)

    def set_px_per_ft(self):
        val, ok = QtWidgets.QInputDialog.getDouble(self, "Scale", "Pixels per foot", self.px_per_ft, 1.0, 1000.0, 2)
        if ok:
            self.px_per_ft = float(val); self.lbl_scale.setText(f"px/ft: {self.px_per_ft:.2f}")
            self._apply_snap_step_from_inches(getattr(self, "snap_step_in", 0.0))

    def _apply_snap_step_from_inches(self, inches: float):
        self.snap_step_in = inches
        if inches <= 0:
            self.scene.snap_step_px = 0.0; self.snap_label = "grid"
        else:
            ft = inches / 12.0
            self.scene.snap_step_px = ft_to_px(ft, self.px_per_ft)
            self.snap_label = f'{int(inches)}"'
        self.statusBar().showMessage(f"Snap: {self.snap_label}")

    def set_snap_inches(self, inches: float):
        self._apply_snap_step_from_inches(inches)

    def change_grid_size(self, v: int):
        self.scene.grid_size = int(v); self.scene.update()

    # history (basic for future undo/redo wiring)
    def serialize_state(self):
        return {"grid":int(self.scene.grid_size), "snap":bool(self.scene.snap_enabled),
                "px_per_ft": float(self.px_per_ft)}

    def push_history(self):
        if self.history_index < len(self.history)-1: self.history = self.history[:self.history_index+1]
        self.history.append(self.serialize_state()); self.history_index += 1

    def start_dimension(self):
        self.dim_tool.start()

    def fit_view_to_content(self):
        rect=self.scene.itemsBoundingRect().adjusted(-100,-100,100,100)
        if rect.isNull(): rect=QtCore.QRectF(0,0,2000,1500)
        self.view.fitInView(rect, Qt.KeepAspectRatio)

    # context menu
    def canvas_menu(self, global_pos):
        m = QMenu(self)
        m.addAction("Fit View (F2)", self.fit_view_to_content)
        m.addSeparator()
        m.addAction("Draw Line", lambda: self.draw.set_mode(draw_tools.DrawMode.LINE))
        m.addAction("Draw Rect", lambda: self.draw.set_mode(draw_tools.DrawMode.RECT))
        m.addAction("Draw Circle", lambda: self.draw.set_mode(draw_tools.DrawMode.CIRCLE))
        m.addAction("Draw Polyline", lambda: self.draw.set_mode(draw_tools.DrawMode.POLYLINE))
        m.addSeparator()
        m.addAction("Dimension", self.start_dimension)
        m.exec(global_pos)

def create_window(): return MainWindow()

def main():
    app = QApplication([])
    w = create_window(); w.show(); app.exec()
