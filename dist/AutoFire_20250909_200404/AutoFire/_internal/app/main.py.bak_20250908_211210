
import os, json, zipfile

from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtCore import Qt, QPointF, QSize
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QHBoxLayout, QVBoxLayout,
    QListWidget, QListWidgetItem, QLineEdit, QLabel, QToolBar, QFileDialog,
    QGraphicsView, QGraphicsPathItem, QMenu, QDockWidget, QCheckBox, QSpinBox, QComboBox, QMessageBox
)
from PySide6.QtPrintSupport import QPrinter, QPrintDialog

from app.scene import GridScene, DEFAULT_GRID_SIZE
from app.device import DeviceItem
from app import catalog
from app.tools import draw as draw_tools
from app.layout import PageFrame, PAGE_SIZES
from app.tools.array import ArraySpec, fill_rect_with_points

try:
    from app.tools.dimension import DimensionTool
except Exception:
    class DimensionTool:
        def __init__(self, *a, **k): self.active=False
        def start(self): self.active=True
        def on_mouse_move(self, *a, **k): pass
        def on_click(self, *a, **k): self.active=False; return True

APP_VERSION = "0.6.1-placefix"
APP_TITLE = f"Auto-Fire {APP_VERSION}"
from app import units

PREF_DIR = os.path.join(os.path.expanduser("~"), "AutoFire")
PREF_PATH = os.path.join(PREF_DIR, "preferences.json")
LOG_DIR = os.path.join(PREF_DIR, "logs")

def ensure_pref_dir():
    try:
        os.makedirs(PREF_DIR, exist_ok=True); os.makedirs(LOG_DIR, exist_ok=True)
    except Exception:
        pass

def load_prefs():
    ensure_pref_dir()
    if os.path.exists(PREF_PATH):
        try:
            with open(PREF_PATH, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            pass
    return {}

def save_prefs(p):
    ensure_pref_dir()
    try:
        with open(PREF_PATH, "w", encoding="utf-8") as f:
            json.dump(p, f, indent=2)
    except Exception:
        pass

def apply_theme(theme: str):
    app = QtWidgets.QApplication.instance()
    if not app: return
    if (theme or "").lower() == "light":
        app.setPalette(app.style().standardPalette())
        return
    pal = QtGui.QPalette()
    pal.setColor(QtGui.QPalette.Window, QtGui.QColor(53,53,53))
    pal.setColor(QtGui.QPalette.WindowText, Qt.white)
    pal.setColor(QtGui.QPalette.Base, QtGui.QColor(35,35,35))
    pal.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(53,53,53))
    pal.setColor(QtGui.QPalette.ToolTipBase, Qt.white)
    pal.setColor(QtGui.QPalette.ToolTipText, Qt.white)
    pal.setColor(QtGui.QPalette.Text, Qt.white)
    pal.setColor(QtGui.QPalette.Button, QtGui.QColor(53,53,53))
    pal.setColor(QtGui.QPalette.ButtonText, Qt.white)
    pal.setColor(QtGui.QPalette.BrightText, Qt.red)
    pal.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42,130,218))
    pal.setColor(QtGui.QPalette.HighlightedText, Qt.black)
    app.setPalette(pal)

class CanvasView(QGraphicsView):
    def __init__(self, scene, devices_group, wires_group, sketch_group, overlay_group, window_ref):
        super().__init__(scene)
        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.TextAntialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setMouseTracking(True)
        self.current_proto = None
        self.devices_group = devices_group
        self.wires_group = wires_group
        self.sketch_group = sketch_group
        self.overlay_group = overlay_group
        self.ortho = False
        self.win = window_ref

        # Area-array interaction
        self.area_array_active = False
        self.area_first = None
        self.area_rubber = QtWidgets.QGraphicsRectItem()
        pen = QtGui.QPen(QtGui.QColor(120,200,255,200)); pen.setStyle(Qt.DashLine); pen.setCosmetic(True)
        self.area_rubber.setPen(pen); self.area_rubber.setBrush(QtGui.QColor(120,200,255,40))
        self.area_rubber.setZValue(500); self.area_rubber.setVisible(False)
        self.area_rubber.setParentItem(self.overlay_group)

        # Crosshair
        self.cross_v = QtWidgets.QGraphicsLineItem(); self.cross_h = QtWidgets.QGraphicsLineItem()
        pen2 = QtGui.QPen(QtGui.QColor(160,160,160,190)); pen2.setCosmetic(True); pen2.setStyle(Qt.DashLine)
        self.cross_v.setPen(pen2); self.cross_h.setPen(pen2)
        self.cross_v.setParentItem(self.overlay_group); self.cross_h.setParentItem(self.overlay_group)
        self.show_crosshair = True

    def set_current_device(self, proto: dict):
        self.current_proto = proto
        if proto:
            self.win.statusBar().showMessage(f"Ready to place: {proto.get('name','Device')} â€” click on canvas", 3500)

    def _update_crosshair(self, sp: QPointF):
        if not self.show_crosshair: return
        rect = self.scene().sceneRect()
        self.cross_v.setLine(sp.x(), rect.top(), sp.x(), rect.bottom())
        self.cross_h.setLine(rect.left(), sp.y(), rect.right(), sp.y())
        from app import units as _u
        dx_ft = _u.px_to_ft(sp.x(), self.win.px_per_ft)
        dy_ft = _u.px_to_ft(sp.y(), self.win.px_per_ft)
        self.win.statusBar().showMessage(f"x={_u.fmt_ft_inches(dx_ft)}   y={_u.fmt_ft_inches(dy_ft)}   scale={self.win.px_per_ft:.2f} px/ft  snap={self.win.snap_label}")

    def wheelEvent(self, e: QtGui.QWheelEvent):
        s = 1.15 if e.angleDelta().y() > 0 else 1/1.15
        self.scale(s, s)

    def keyPressEvent(self, e: QtGui.QKeyEvent):
        if e.key()==Qt.Key_Shift: self.ortho=True; e.accept(); return
        if e.key()==Qt.Key_C: self.show_crosshair = not self.show_crosshair; e.accept(); return
        if e.key()==Qt.Key_G: self.win.set_generic_proto(); e.accept(); return
        if e.key()==Qt.Key_Delete: self.win.delete_selected(); e.accept(); return
        if e.key()==Qt.Key_R: self.win.rotate_selected(); e.accept(); return
        if e.key()==Qt.Key_Escape:
            if self.area_array_active:
                self.area_array_active=False; self.area_first=None; self.area_rubber.setVisible(False); e.accept(); return
            if getattr(self.win, "draw", None): self.win.draw.finish(); e.accept(); return
        super().keyPressEvent(e)

    def mousePressEvent(self, e: QtGui.QMouseEvent):
        sp = self.scene().snap(self.mapToScene(e.position().toPoint()))
        if e.button()==Qt.RightButton:
            self.win.canvas_menu(e.globalPosition().toPoint()); e.accept(); return

        if e.button()==Qt.LeftButton:
            # Priority: area-array, drawing, dimension, placement
            if self.area_array_active:
                if self.area_first is None:
                    self.area_first = sp
                    self.win.statusBar().showMessage("Array: pick opposite corner (Esc to cancel)")
                else:
                    rect = QtCore.QRectF(self.area_first, sp).normalized()
                    self.area_array_active=False; self.area_first=None; self.area_rubber.setVisible(False)
                    self.win.place_array_in_rect(rect)
                e.accept(); return

            if getattr(self.win, "draw", None) and self.win.draw.mode != 0:
                if self.win.draw.on_click(sp, shift_ortho=self.ortho):
                    self.win.push_history(); e.accept(); return

            if getattr(self.win, "dim_tool", None) and self.win.dim_tool.active:
                if self.win.dim_tool.on_click(sp):
                    e.accept(); return

            # If clicking on an existing item, don't place a new one
            under = self.items(e.position().toPoint())
            if any(isinstance(x, QtWidgets.QGraphicsItem) and not isinstance(x, QtWidgets.QGraphicsPixmapItem) and x is not self.area_rubber for x in under):
                super().mousePressEvent(e)
                return

            # Place device (always works, even if no catalog)
            d = self.current_proto or {"symbol":"GEN","name":"Generic Device","manufacturer":"Generic","part_number":""}
            it = DeviceItem(sp.x(), sp.y(), d.get("symbol","?"), d.get("name","Device"), d.get("manufacturer",""), d.get("part_number",""))
            it.setParentItem(self.devices_group)
            self.win.push_history()
            e.accept(); return

        super().mousePressEvent(e)

    def mouseMoveEvent(self, e: QtGui.QMouseEvent):
        sp = self.mapToScene(e.position().toPoint())
        self._update_crosshair(sp)
        if self.area_array_active and self.area_first is not None:
            rect = QtCore.QRectF(self.area_first, sp).normalized()
            self.area_rubber.setRect(rect); self.area_rubber.setVisible(True)
        if getattr(self.win, "draw", None): self.win.draw.on_mouse_move(sp, shift_ortho=self.ortho)
        if getattr(self.win, "dim_tool", None): self.win.dim_tool.on_mouse_move(sp)
        super().mouseMoveEvent(e)

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(APP_TITLE)
        self.resize(1400, 900)
        self.prefs = load_prefs()
        self.px_per_ft = float(self.prefs.get("px_per_ft", 12.0))
        self.snap_label = self.prefs.get("snap_label", "grid")
        self.snap_step_in = float(self.prefs.get("snap_step_in", 0.0))

        self.devices_all = catalog.load_catalog()

        self.scene = GridScene(int(self.prefs.get("grid", DEFAULT_GRID_SIZE)), 0,0,10000,8000)
        self.scene.snap_enabled = bool(self.prefs.get("snap", True))
        self._apply_snap_step_from_inches(self.snap_step_in)

        self.layer_underlay = QtWidgets.QGraphicsItemGroup(); self.layer_underlay.setZValue(-10); self.scene.addItem(self.layer_underlay)
        self.layer_sketch   = QtWidgets.QGraphicsItemGroup(); self.layer_sketch.setZValue(40);   self.scene.addItem(self.layer_sketch)
        self.layer_wires    = QtWidgets.QGraphicsItemGroup(); self.layer_wires.setZValue(60);    self.scene.addItem(self.layer_wires)
        self.layer_devices  = QtWidgets.QGraphicsItemGroup(); self.layer_devices.setZValue(100);  self.scene.addItem(self.layer_devices)
        self.layer_overlay  = QtWidgets.QGraphicsItemGroup(); self.layer_overlay.setZValue(200);  self.scene.addItem(self.layer_overlay)

        self.view = CanvasView(self.scene, self.layer_devices, self.layer_wires, self.layer_sketch, self.layer_overlay, self)

        self.draw = draw_tools.DrawController(self, self.layer_sketch)
        try:
            self.dim_tool = DimensionTool(self, self.layer_overlay)
        except Exception:
            self.dim_tool = None

        menubar = self.menuBar()
        m_file = menubar.addMenu("&File")
        m_file.addAction("New", self.new_project, QtGui.QKeySequence.New)
        m_file.addAction("Openâ€¦", self.open_project, QtGui.QKeySequence.Open)
        m_file.addAction("Save Asâ€¦", self.save_project_as, QtGui.QKeySequence.SaveAs)
        m_file.addSeparator()
        m_file.addAction("Import DXF Underlayâ€¦", self.import_dxf_underlay)
        m_file.addAction("Import Image Underlayâ€¦", self.import_image_underlay)
        m_file.addSeparator()
        m_file.addAction("Quit", self.close, QtGui.QKeySequence.Quit)

        m_tools = menubar.addMenu("&Tools")
        def add_tool(name, cb):
            act = QtGui.QAction(name, self); act.triggered.connect(cb); m_tools.addAction(act); return act
        self.act_draw_line    = add_tool("Draw Line",    lambda: self.draw.set_mode(draw_tools.DrawMode.LINE))
        self.act_draw_rect    = add_tool("Draw Rect",    lambda: self.draw.set_mode(draw_tools.DrawMode.RECT))
        self.act_draw_circle  = add_tool("Draw Circle",  lambda: self.draw.set_mode(draw_tools.DrawMode.CIRCLE))
        self.act_draw_poly    = add_tool("Draw Polyline",lambda: self.draw.set_mode(draw_tools.DrawMode.POLYLINE))
        m_tools.addSeparator()
        m_tools.addAction("Array in Areaâ€¦", self.start_area_array)
        if self.dim_tool:
            m_tools.addAction("Dimension (D)", self.start_dimension)

        m_view = menubar.addMenu("&View")
        self.act_view_grid = QtGui.QAction("Grid", self, checkable=True); self.act_view_grid.setChecked(True); self.act_view_grid.toggled.connect(self.toggle_grid); m_view.addAction(self.act_view_grid)
        self.act_view_snap = QtGui.QAction("Snap", self, checkable=True); self.act_view_snap.setChecked(self.scene.snap_enabled); self.act_view_snap.toggled.connect(self.toggle_snap); m_view.addAction(self.act_view_snap)
        self.act_view_cross = QtGui.QAction("Crosshair (C)", self, checkable=True); self.act_view_cross.setChecked(True); self.act_view_cross.toggled.connect(self.toggle_crosshair); m_view.addAction(self.act_view_cross)
        m_view.addSeparator()
        act_scale = QtGui.QAction("Set Pixels per Footâ€¦", self); act_scale.triggered.connect(self.set_px_per_ft); m_view.addAction(act_scale)

        m_help = menubar.addMenu("&Help")
        m_help.addAction("About AutoFireâ€¦", self.show_about)

        tb = QToolBar("Main"); tb.setIconSize(QSize(16,16)); self.addToolBar(tb)
        tb.addAction(self.act_view_grid); tb.addAction(self.act_view_snap); tb.addAction(self.act_view_cross)

        left = QWidget(); ll = QVBoxLayout(left)
        ll.addWidget(QLabel("Device Palette"))
        self.search = QLineEdit(); self.search.setPlaceholderText("Search name / part numberâ€¦")
        self.cmb_mfr = QComboBox(); self.cmb_type = QComboBox()
        ll_top = QHBoxLayout(); ll_top.addWidget(QLabel("Manufacturer:")); ll_top.addWidget(self.cmb_mfr)
        ll_typ = QHBoxLayout(); ll_typ.addWidget(QLabel("Type:")); ll_typ.addWidget(self.cmb_type)
        self.list = QListWidget()
        ll.addLayout(ll_top); ll.addLayout(ll_typ); ll.addWidget(self.search); ll.addWidget(self.list)

        self.devices_all = self.devices_all or []
        self._populate_filters(); self._refresh_device_list()
        self.search.textChanged.connect(self._refresh_device_list)
        self.cmb_mfr.currentIndexChanged.connect(self._refresh_device_list)
        self.cmb_type.currentIndexChanged.connect(self._refresh_device_list)
        self.list.itemClicked.connect(self.choose_device)

        # Select first device by default (else generic)
        if self.list.count() > 0:
            self.list.setCurrentRow(0)
            self.choose_device(self.list.item(0))
        else:
            self.set_generic_proto()

        splitter = QtWidgets.QSplitter(); splitter.addWidget(left); splitter.addWidget(self.view); splitter.setStretchFactor(1,1)
        container = QWidget(); lay = QHBoxLayout(container); lay.addWidget(splitter); self.setCentralWidget(container)

        dock = QDockWidget("Layers / Controls", self); panel = QWidget(); form = QVBoxLayout(panel)
        self.chk_underlay = QCheckBox("Underlay"); self.chk_underlay.setChecked(True); self.chk_underlay.toggled.connect(lambda v: self.layer_underlay.setVisible(v)); form.addWidget(self.chk_underlay)
        self.chk_sketch = QCheckBox("Sketch"); self.chk_sketch.setChecked(True); self.chk_sketch.toggled.connect(lambda v: self.layer_sketch.setVisible(v)); form.addWidget(self.chk_sketch)
        self.chk_wires = QCheckBox("Wiring"); self.chk_wires.setChecked(True); self.chk_wires.toggled.connect(lambda v: self.layer_wires.setVisible(v)); form.addWidget(self.chk_wires)
        self.chk_devices = QCheckBox("Devices"); self.chk_devices.setChecked(True); self.chk_devices.toggled.connect(lambda v: self.layer_devices.setVisible(v)); form.addWidget(self.chk_devices)
        form.addWidget(QLabel("Grid Size"))
        self.spin_grid = QSpinBox(); self.spin_grid.setRange(2, 500); self.spin_grid.setValue(self.scene.grid_size); self.spin_grid.valueChanged.connect(self.change_grid_size); form.addWidget(self.spin_grid)
        panel.setLayout(form); dock.setWidget(panel); self.addDockWidget(Qt.RightDockWidgetArea, dock)

        # SHORTCUTS
        QtGui.QShortcut(QtGui.QKeySequence("Ctrl+Z"), self, activated=self.undo)
        QtGui.QShortcut(QtGui.QKeySequence("Ctrl+Y"), self, activated=self.redo)
        if self.dim_tool:
            QtGui.QShortcut(QtGui.QKeySequence("D"), self, activated=self.start_dimension)
        QtGui.QShortcut(QtGui.QKeySequence("Delete"), self, activated=self.delete_selected)
        QtGui.QShortcut(QtGui.QKeySequence("Ctrl+D"), self, activated=self.duplicate_selected)
        QtGui.QShortcut(QtGui.QKeySequence("G"), self, activated=self.set_generic_proto)

        self.history = []; self.history_index = -1
        self.push_history()

    # ---- palette ----
    def _populate_filters(self):
        def list_mfrs(devs):
            s = set(d.get("manufacturer","") for d in devs if d.get("manufacturer"))
            return ["(Any)"] + sorted(s) if s else ["(Any)"]
        def list_types(devs):
            s = set(d.get("type","") for d in devs if d.get("type"))
            return ["(Any)"] + sorted(s) if s else ["(Any)"]

        mfrs = list_mfrs(self.devices_all)
        types = list_types(self.devices_all)
        self.cmb_mfr.clear(); self.cmb_mfr.addItems(mfrs)
        self.cmb_type.clear(); self.cmb_type.addItems(types)

    def _refresh_device_list(self):
        q = self.search.text().lower().strip()
        want_mfr = self.cmb_mfr.currentText()
        want_type = self.cmb_type.currentText()
        self.list.clear()
        for d in self.devices_all:
            if want_mfr and want_mfr != "(Any)" and d.get("manufacturer") != want_mfr: continue
            if want_type and want_type != "(Any)" and d.get("type") != want_type: continue
            txt = f"{d.get('name','Device')} ({d.get('symbol','?')})"
            if q and q not in txt.lower() and q not in (d.get('part_number','').lower()): continue
            it = QListWidgetItem(txt); it.setData(Qt.UserRole, d); self.list.addItem(it)

    def choose_device(self, it: QListWidgetItem):
        self.view.set_current_device(it.data(Qt.UserRole)); self.statusBar().showMessage(f"Selected: {it.data(Qt.UserRole).get('name','Device')}")

    # ---- tools ----
    def start_area_array(self):
        self.view.area_array_active = True
        self.view.area_first = None
        self.statusBar().showMessage("Array: click first corner, then opposite corner (Esc to cancel)")

    def place_array_in_rect(self, rect: QtCore.QRectF):
        proto = self.view.current_proto or {"symbol":"GEN","name":"Generic Device","manufacturer":"Generic","part_number":""}
        spacing_ft = self.snap_step_in/12.0 if self.snap_step_in>0 else 10.0
        pts = fill_rect_with_points(rect, self.px_per_ft, ArraySpec(spacing_ft=spacing_ft))
        for p in pts:
            it = DeviceItem(p.x(), p.y(), proto.get("symbol","?"), proto.get("name","Device"), proto.get("manufacturer",""), proto.get("part_number",""))
            it.setParentItem(self.layer_devices)
        self.push_history()
        self.statusBar().showMessage(f"Placed {len(pts)} devices")

    # ---- view toggles ----
    def toggle_grid(self, on: bool): self.scene.show_grid = bool(on); self.scene.update()
    def toggle_snap(self, on: bool): self.scene.snap_enabled = bool(on)
    def toggle_crosshair(self, on: bool): self.view.show_crosshair = bool(on)

    def set_px_per_ft(self):
        val, ok = QtWidgets.QInputDialog.getDouble(self, "Scale", "Pixels per foot", self.px_per_ft, 1.0, 1000.0, 2)
        if ok:
            self.px_per_ft = float(val)
            self.prefs["px_per_ft"] = self.px_per_ft
            save_prefs(self.prefs)
            self._apply_snap_step_from_inches(self.snap_step_in)

    def _apply_snap_step_from_inches(self, inches: float):
        if inches <= 0:
            self.scene.snap_step_px = 0.0
            self.snap_label = "grid"
        else:
            ft = inches / 12.0
            self.scene.snap_step_px = (ft * self.px_per_ft)
            self.snap_label = f'{int(inches)}"'
        self.prefs["snap_step_in"] = inches
        self.prefs["snap_label"] = self.snap_label
        save_prefs(self.prefs)

    def set_snap_inches(self, inches: float):
        self._apply_snap_step_from_inches(inches)

    # ---- context menu ----
    def canvas_menu(self, global_pos):
        menu = QMenu(self)
        sel = [it for it in self.scene.selectedItems() if isinstance(it, DeviceItem)]
        if sel:
            d = sel[0]
            act_prop = menu.addAction("Propertiesâ€¦")
            act_dup = menu.addAction("Duplicate")
            act_del = menu.addAction("Delete")
            act_front = menu.addAction("Bring to Front")
            act_back = menu.addAction("Send to Back")
            act_lock = menu.addAction("Lock" if not getattr(d, "locked", False) else "Unlock")

            act = menu.exec(global_pos)
            if act == act_prop:
                self.edit_device(d)
            elif act == act_dup:
                self.duplicate_selected()
            elif act == act_del:
                self.delete_selected()
            elif act == act_front:
                d.setZValue(d.zValue()+10); self.push_history()
            elif act == act_back:
                d.setZValue(d.zValue()-10); self.push_history()
            elif act == act_lock:
                d.set_locked(not getattr(d, "locked", False)); self.push_history()
        else:
            menu.addAction("Array in Areaâ€¦", self.start_area_array)
            menu.addAction("Clear Underlay", self.clear_underlay)
            menu.exec(global_pos)

    def edit_device(self, item: DeviceItem):
        try:
            from app.dialogs.device_props import DevicePropsDialog
        except Exception:
            QMessageBox.information(self, "Properties", "Properties dialog unavailable in this build.")
            return
        dlg = DevicePropsDialog(self, item, self.px_per_ft)
        if dlg.exec() == QtWidgets.QDialog.Accepted:
            v = dlg.values()
            item.set_label_text(v["name"] or item.name)
            item.name = v["name"] or item.name
            item.symbol = v["symbol"] or item.symbol
            item.manufacturer = v["manufacturer"] or item.manufacturer
            item.part_number = v["part_number"] or item.part_number
            dx, dy = v["label_offset_px"]; item.set_label_offset(dx, dy)
            self.push_history()

    # ---- serialize ----
    def serialize_state(self):
        devs = []
        for it in self.layer_devices.childItems():
            if isinstance(it, DeviceItem): devs.append(it.to_json())
        return {"grid":int(self.scene.grid_size), "snap":bool(self.scene.snap_enabled),
                "px_per_ft": float(self.px_per_ft),
                "snap_step_in": float(self.snap_step_in),
                "underlay":{"opacity":1.0},"devices":devs,"wires":[]}

    def load_state(self, data):
        for it in list(self.layer_devices.childItems()): it.scene().removeItem(it)
        for it in list(self.layer_wires.childItems()): it.scene().removeItem(it)
        self.scene.snap_enabled = bool(data.get("snap", True)); self.act_view_snap.setChecked(self.scene.snap_enabled)
        self.scene.grid_size = int(data.get("grid", DEFAULT_GRID_SIZE)); self.spin_grid.setValue(self.scene.grid_size)
        self.px_per_ft = float(data.get("px_per_ft", self.px_per_ft))
        self.snap_step_in = float(data.get("snap_step_in", self.snap_step_in))
        self._apply_snap_step_from_inches(self.snap_step_in)
        for d in data.get("devices", []):
            it = DeviceItem.from_json(d); it.setParentItem(self.layer_devices)

    def push_history(self):
        if self.history_index < len(self.history)-1: self.history = self.history[:self.history_index+1]
        self.history.append(self.serialize_state()); self.history_index += 1

    def undo(self):
        if self.history_index>0:
            self.history_index-=1; self.load_state(self.history[self.history_index]); self.statusBar().showMessage("Undo")

    def redo(self):
        if self.history_index < len(self.history)-1:
            self.history_index+=1; self.load_state(self.history[self.history_index]); self.statusBar().showMessage("Redo")

    # ---- underlay ----
    def _build_underlay_path(self, msp):
        path = QtGui.QPainterPath()
        for e in msp:
            t = e.dxftype()
            if t=="LINE":
                sx,sy,_=e.dxf.start; ex,ey,_=e.dxf.end
                path.moveTo(float(sx),float(sy)); path.lineTo(float(ex),float(ey))
            elif t=="CIRCLE":
                cx,cy,_=e.dxf.center; r=float(e.dxf.radius); rect=QtCore.QRectF(cx-r, cy-r, 2*r, 2*r); path.addEllipse(rect)
            elif t=="ARC":
                cx,cy,_=e.dxf.center; r=float(e.dxf.radius)
                start=float(e.dxf.start_angle); end=float(e.dxf.end_angle); rect=QtCore.QRectF(cx-r, cy-r, 2*r, 2*r)
                path.arcMoveTo(rect, start); path.arcTo(rect, start, end-start)
        return path

    def _apply_underlay_path(self, path):
        for it in list(self.layer_underlay.childItems()): it.scene().removeItem(it)
        pen=QtGui.QPen(Qt.darkGray); pen.setCosmetic(True); pen.setWidthF(0)
        item=QGraphicsPathItem(path); item.setPen(pen); item.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, False); item.setParentItem(self.layer_underlay)

    def _load_underlay(self, path):
        try:
            import ezdxf
        except Exception as ex:
            QMessageBox.critical(self,"DXF Import Error","DXF support (ezdxf) is not available in this build.\n\n"+str(ex))
            return
        try:
            doc = ezdxf.readfile(path); msp = doc.modelspace(); p = self._build_underlay_path(msp); self._apply_underlay_path(p)
        except Exception as ex:
            QMessageBox.critical(self,"DXF Import Error", str(ex))

    def import_dxf_underlay(self):
        p,_ = QFileDialog.getOpenFileName(self,"Import DXF Underlay","","DXF Files (*.dxf)")
        if not p: return
        self._load_underlay(p)

    def import_image_underlay(self):
        p,_ = QFileDialog.getOpenFileName(self,"Import Image Underlay","","Images (*.png *.jpg *.jpeg *.bmp *.tif *.tiff)")
        if not p: return
        img = QtGui.QImage(p)
        if img.isNull():
            QMessageBox.critical(self,"Image Import Error","Could not read the selected image.")
            return
        pix = QtGui.QPixmap.fromImage(img)
        item = QtWidgets.QGraphicsPixmapItem(pix)
        item.setOpacity(0.85)
        item.setZValue(-15)
        item.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable, True)
        item.setParentItem(self.layer_underlay)

    def clear_underlay(self):
        for it in list(self.layer_underlay.childItems()): it.scene().removeItem(it)

    def new_project(self):
        self.clear_underlay()
        for it in list(self.layer_devices.childItems()): it.scene().removeItem(it)
        for it in list(self.layer_wires.childItems()): it.scene().removeItem(it)
        self.push_history(); self.statusBar().showMessage("New project")

    def save_project_as(self):
        p,_=QFileDialog.getSaveFileName(self,"Save Project As","","AutoFire Bundle (*.autofire)")
        if not p: return
        if not p.lower().endswith(".autofire"): p += ".autofire"
        try:
            data=self.serialize_state()
            with zipfile.ZipFile(p,"w",compression=zipfile.ZIP_DEFLATED) as z:
                z.writestr("project.json", json.dumps(data, indent=2))
            self.statusBar().showMessage(f"Saved: {os.path.basename(p)}")
        except Exception as ex:
            QMessageBox.critical(self,"Save Project Error", str(ex))

    def open_project(self):
        p,_=QFileDialog.getOpenFileName(self,"Open Project","","AutoFire Bundle (*.autofire)")
        if not p: return
        try:
            with zipfile.ZipFile(p,"r") as z:
                data=json.loads(z.read("project.json").decode("utf-8"))
            self.load_state(data); self.push_history(); self.statusBar().showMessage(f"Opened: {os.path.basename(p)}")
        except Exception as ex:
            QMessageBox.critical(self,"Open Project Error", str(ex))

    def change_grid_size(self, v: int):
        self.scene.grid_size = int(v); self.scene.update()

    def fit_view_to_content(self):
        rect=self.scene.itemsBoundingRect().adjusted(-100,-100,100,100)
        if rect.isNull(): rect=QtCore.QRectF(0,0,1000,800)
        self.view.fitInView(rect, Qt.KeepAspectRatio)

    def start_dimension(self):
        if self.dim_tool: self.dim_tool.start()

    # Selection ops
    def delete_selected(self):
        for it in list(self.scene.selectedItems()):
            if isinstance(it, DeviceItem) and getattr(it, "locked", False):
                continue
            it.scene().removeItem(it)
        self.push_history()

    def duplicate_selected(self):
        sel = [it for it in self.scene.selectedItems() if isinstance(it, DeviceItem)]
        for d in sel:
            it = DeviceItem(d.pos().x()+10, d.pos().y()+10, d.symbol, d.name, d.manufacturer, d.part_number)
            it.setParentItem(self.layer_devices)
        self.push_history()

    def set_generic_proto(self):
        self.view.set_current_device({"symbol":"GEN","name":"Generic Device","manufacturer":"Generic","part_number":""})

    def show_about(self):
        QtWidgets.QMessageBox.information(self,"About", f"Auto-Fire\nVersion {APP_VERSION}")

# factory used by boot.py
def create_window():
    return MainWindow()

def main():
    app = QApplication([])
    # theme
    prefs = load_prefs()
    apply_theme(prefs.get("theme","dark"))
    win = create_window()
    win.show()
    app.exec()

if __name__ == "__main__":
    main()
