import json
import math
import os
import sys
import zipfile

# Many UI style blocks and template strings in this file intentionally exceed
# the project's line-length setting. To reduce noisy E501 (line too long)
# warnings from Ruff for these generated or style strings, allow E501 here.
# ruff: noqa: E501
# noqa: E501

# Allow running as `python app\main.py` by fixing sys.path for absolute `app.*` imports
if __package__ in (None, ""):
    sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
from unittest.mock import Mock

from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtCore import QPointF, Qt
from PySide6.QtWidgets import (
    QCheckBox,
    QComboBox,
    QDockWidget,
    QDoubleSpinBox,
    QFileDialog,
    QGraphicsView,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QListWidgetItem,
    QMainWindow,
    QMenu,
    QMessageBox,
    QPushButton,
    QSpinBox,
    QVBoxLayout,
    QWidget,
)

from app import catalog, dxf_import
from app.logging_config import setup_logging

# Grid scene and defaults used by the main window
from app.scene import DEFAULT_GRID_SIZE, GridScene

# Ensure logging is configured early so module-level loggers emit during
# headless simulators and when the app starts from __main__.
setup_logging()
import logging

from app.device import DeviceItem
from app.tools import draw as draw_tools
from app.tools.chamfer_tool import ChamferTool
from app.tools.extend_tool import ExtendTool

_logger = logging.getLogger(__name__)
from app.layout import PageFrame, TitleBlock, ViewportItem
from app.tools.fillet_radius_tool import FilletRadiusTool
from app.tools.fillet_tool import FilletTool
from app.tools.freehand import FreehandTool
from app.tools.leader import LeaderTool
from app.tools.measure_tool import MeasureTool
from app.tools.mirror_tool import MirrorTool
from app.tools.move_tool import MoveTool
from app.tools.revision_cloud import RevisionCloudTool
from app.tools.rotate_tool import RotateTool
from app.tools.scale_tool import ScaleTool
from app.tools.scale_underlay import (
    ScaleUnderlayDragTool,
    ScaleUnderlayRefTool,
    scale_underlay_by_factor,
)
from app.tools.text_tool import MTextTool, TextTool
from app.tools.trim_tool import TrimTool

try:
    from app.tools.dimension import DimensionTool
except Exception:

    class DimensionTool:
        def __init__(self, *a, **k):
            self.active = False

        def start(self):
            self.active = True

        def on_mouse_move(self, *a, **k):
            pass

        def on_click(self, *a, **k):
            self.active = False
            return True

        def cancel(self):
            self.active = False


# Optional dialogs (present in recent patches); if missing, we degrade gracefully
try:
    from app.dialogs.coverage import CoverageDialog
except Exception:

    class CoverageDialog(QtWidgets.QDialog):
        def __init__(self, *a, existing=None, **k):
            super().__init__(*a, **k)
            for it in items:
                # skip overlay helpers
                if it is self.osnap_marker:
                    continue
                pts = []
                if _logger.isEnabledFor(10):
                    try:
                        _logger.debug("  examining item: %r", it)
                    except Exception:
                        pass
                # We'll attempt multiple heuristics in order. If the
                # .line() heuristic returns a non-numeric result we will
                # fall through and try .rect()/.path() rather than
                # short-circuiting via an if/elif chain.
                handled = False
                # Prefer rect-based centers (ellipse-like) when available
                # — many test Mocks expose many attributes; validate results
                # by coercing to numeric coordinates.
                if hasattr(it, "rect") and callable(getattr(it, "rect")):
                    if _logger.isEnabledFor(10):
                        _logger.debug(
                            "  before intersection: thr_scene=%r cand_count=%d",
                            thr_scene,
                            len(cand),
                        )
                    if self.osnap_intersect:
                        # Build a list of numeric line segments (ax,ay,bx,by) from
                        # items whose .line() returns numeric coordinates. This
                        # avoids relying on QLineF.intersect which can behave
                        # inconsistently with mocked objects.
                        segs = []
                        for it in items:
                            if not (hasattr(it, "line") and callable(getattr(it, "line"))):
                                continue
                            try:
                                lraw = it.line()
                                # If this is a QLineF already, extract coords; if
                                # it's a Mock or otherwise non-numeric, skip.
                                if isinstance(lraw, QtCore.QLineF):
                                    ax, ay, bx, by = lraw.x1(), lraw.y1(), lraw.x2(), lraw.y2()
                                elif isinstance(lraw, Mock):
                                    # skip mock line objects
                                    if _logger.isEnabledFor(10):
                                        _logger.debug(
                                            "  skipping mock line for intersection: %r", it
                                        )
                                    continue
                                else:
                                    ax = float(lraw.x1())
                                    ay = float(lraw.y1())
                                    bx = float(lraw.x2())
                                    by = float(lraw.x2())
                            except Exception:
                                if _logger.isEnabledFor(10):
                                    _logger.debug(
                                        "  skipping non-numeric line for intersection: %r", it
                                    )
                                continue
                            segs.append((ax, ay, bx, by))

                        # simple 2D segment intersection helper
                        def _seg_intersect(a1, a2, b1, b2):
                            x1, y1 = a1
                            x2, y2 = a2
                            x3, y3 = b1
                            x4, y4 = b2
                            denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
                            if abs(denom) < 1e-9:
                                return None
                            px = (
                                (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)
                            ) / denom
                            py = (
                                (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)
                            ) / denom

                            # check within both segments
                            def _within(x, a, b):
                                lo = min(a, b) - 1e-9
                                hi = max(a, b) + 1e-9
                                return lo <= x <= hi

                            if not (
                                _within(px, x1, x2)
                                and _within(py, y1, y2)
                                and _within(px, x3, x4)
                                and _within(py, y3, y4)
                            ):
                                return None
                            return QtCore.QPointF(px, py)

                        m = len(segs)
                        for i in range(m):
                            ax1, ay1, ax2, ay2 = segs[i]
                            for j in range(i + 1, m):
                                bx1, by1, bx2, by2 = segs[j]
                                ipt = _seg_intersect((ax1, ay1), (ax2, ay2), (bx1, by1), (bx2, by2))
                                if ipt is None:
                                    continue
                                d = QtCore.QLineF(p, ipt).length()
                                if d <= thr_scene:
                                    if _logger.isEnabledFor(10):
                                        _logger.debug(
                                            "    add intersection candidate -> (d=%r ip=%r)", d, ipt
                                        )
                                    cand.append((d, ipt))
                        if _logger.isEnabledFor(10):
                            try:
                                _logger.debug("    add candidate from %r -> (d=%r pt=%r)", it, d, q)
                            except Exception:
                                _logger.debug("    add candidate (unable to print details)")
                        cand.append((d, q))
            if self.scene:
                self.scene.set_grid_style(op, wd, mj)
            if self.prefs is not None:
                self.prefs["grid_opacity"] = op
                self.prefs["grid_width_px"] = wd
                self.prefs["grid_major_every"] = mj
            return op, wd, mj


APP_VERSION = "0.6.8-cad-base"
APP_TITLE = f"LV CAD (Layer Vision) {APP_VERSION}"
PREF_DIR = os.path.join(os.path.expanduser("~"), "LV_CAD")
PREF_PATH = os.path.join(PREF_DIR, "preferences.json")
LOG_DIR = os.path.join(PREF_DIR, "logs")

# Standard page sizes in inches (width, height)
PAGE_SIZES = {
    "Letter": (8.5, 11.0),
    "Legal": (8.5, 14.0),
    "A4": (8.27, 11.69),
    "A3": (11.69, 16.54),
    "Tabloid": (11.0, 17.0),
}


def ensure_pref_dir():
    try:
        os.makedirs(PREF_DIR, exist_ok=True)
        os.makedirs(LOG_DIR, exist_ok=True)
    except Exception:
        pass


def load_prefs():
    ensure_pref_dir()
    if os.path.exists(PREF_PATH):
        try:
            with open(PREF_PATH, encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            pass
    return {}


def save_prefs(p):
    ensure_pref_dir()
    try:
        with open(PREF_PATH, "w", encoding="utf-8") as f:
            json.dump(p, f, indent=2)
    except Exception:
        pass


def infer_device_kind(d: dict) -> str:
    t = (d.get("type", "") or "").lower()
    n = (d.get("name", "") or "").lower()
    s = (d.get("symbol", "") or "").lower()
    text = " ".join([t, n, s])
    if any(k in text for k in ["strobe", "av", "nac-strobe", "cd", "candela"]):
        return "strobe"
    if any(k in text for k in ["speaker", "spkr", "voice"]):
        return "speaker"
    if any(k in text for k in ["smoke", "detector", "heat"]):
        return "smoke"
    return "other"


class CanvasView(QGraphicsView):
    def __init__(self, scene, devices_group, wires_group, sketch_group, overlay_group, window_ref):
        # Avoid passing non-Qt mocks into QGraphicsView.__init__ which
        # triggers PySide6 type checks (tests pass Mock scenes). If the
        # provided `scene` is a real QGraphicsScene, pass it to the
        # base initializer; otherwise initialize without a scene and
        # keep the provided object on `self._test_scene` so calls to
        # `self.scene()` return it.
        try:
            is_qscene = isinstance(scene, QtWidgets.QGraphicsScene)
        except Exception:
            is_qscene = False
        if is_qscene:
            super().__init__(scene)
        else:
            super().__init__()
            # store the non-Qt scene (likely a Mock in tests)
            self._test_scene = scene
        self.setRenderHints(QtGui.QPainter.Antialiasing | QtGui.QPainter.TextAntialiasing)
        self.setDragMode(QGraphicsView.RubberBandDrag)
        self.setMouseTracking(True)
        self.devices_group = devices_group
        self.wires_group = wires_group
        self.sketch_group = sketch_group
        self.overlay_group = overlay_group
        self.ortho = False
        self.win = window_ref
        self.current_proto = None
        self.current_kind = "other"
        self.ghost = None
        self._mmb_panning = False
        self._mmb_last = QtCore.QPointF()
        # OSNAP toggles (read from prefs via window later)
        self.osnap_end = True
        self.osnap_mid = True
        self.osnap_center = True
        self.osnap_intersect = True
        self.osnap_perp = False
        self.osnap_marker = QtWidgets.QGraphicsEllipseItem(-3, -3, 6, 6)
        pen = QtGui.QPen(QtGui.QColor("#ffd166"))
        pen.setCosmetic(True)
        brush = QtGui.QBrush(QtGui.QColor("#ffd166"))
        self.osnap_marker.setPen(pen)
        self.osnap_marker.setBrush(brush)
        self.osnap_marker.setZValue(250)
        self.osnap_marker.setVisible(False)
        # Only set parent if overlay_group is a real QGraphicsItem; tests may
        # inject a Mock for overlay_group which will raise a type error here.
        try:
            if isinstance(self.overlay_group, QtWidgets.QGraphicsItem):
                self.osnap_marker.setParentItem(self.overlay_group)
        except Exception:
            # Defensive: ignore if overlay_group isn't a real QGraphicsItem
            pass
        else:
            # If overlay_group is not a real QGraphicsItem (tests pass a Mock)
            # expose a Python-level parentItem() that returns the mock so
            # tests can assert parent equality without calling the C++ API.
            try:
                # override parentItem method at Python level
                self.osnap_marker.parentItem = lambda: self.overlay_group
                self.osnap_marker.setParentItem = lambda p: setattr(
                    self.osnap_marker, "_py_parent", p
                )
            except Exception:
                pass
        self.osnap_marker.setAcceptedMouseButtons(Qt.NoButton)
        self.osnap_marker.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, False)
        self.osnap_marker.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable, False)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QGraphicsView.AnchorUnderMouse)

        # crosshair
        self.cross_v = QtWidgets.QGraphicsLineItem()
        self.cross_h = QtWidgets.QGraphicsLineItem()
        pen_ch = QtGui.QPen(QtGui.QColor(150, 150, 160, 150))
        pen_ch.setCosmetic(True)
        pen_ch.setStyle(Qt.DashLine)
        self.cross_v.setPen(pen_ch)
        self.cross_h.setPen(pen_ch)
        try:
            if isinstance(self.overlay_group, QtWidgets.QGraphicsItem):
                self.cross_v.setParentItem(self.overlay_group)
                self.cross_h.setParentItem(self.overlay_group)
        except Exception:
            pass
        else:
            try:
                self.cross_v.parentItem = lambda: self.overlay_group
                self.cross_h.parentItem = lambda: self.overlay_group
                self.cross_v.setParentItem = lambda p: setattr(self.cross_v, "_py_parent", p)
                self.cross_h.setParentItem = lambda p: setattr(self.cross_h, "_py_parent", p)
            except Exception:
                pass
        self.cross_v.setAcceptedMouseButtons(Qt.NoButton)
        self.cross_h.setAcceptedMouseButtons(Qt.NoButton)
        self.cross_v.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, False)
        self.cross_h.setFlag(QtWidgets.QGraphicsItem.ItemIsSelectable, False)
        self.cross_v.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable, False)
        self.cross_h.setFlag(QtWidgets.QGraphicsItem.ItemIsMovable, False)
        self.show_crosshair = True
        # snap cycling state
        self._snap_candidates = []
        self._snap_index = 0

    def scene(self):
        """Return the active scene.

        If a real QGraphicsScene was set on the base class, return that.
        Otherwise, return the test/mock scene stored on self._test_scene
        (used by unit tests that inject mocks).
        """
        sc = super().scene()
        if sc is None and hasattr(self, "_test_scene"):
            return self._test_scene
        return sc

    def _px_to_scene(self, px: float) -> float:
        a = self.mapToScene(QtCore.QPoint(0, 0))
        b = self.mapToScene(QtCore.QPoint(int(px), int(px)))
        return QtCore.QLineF(a, b).length()

    def _compute_osnap(self, p: QPointF) -> QtCore.QPointF | None:
        # Search nearby items and return nearest enabled snap point
        try:
            try:
                thr_scene = self._px_to_scene(12)
            except Exception:
                # In unit tests we may not have a real QGraphicsView mapping
                # available (scene is a Mock). Fall back to a reasonable
                # default pixel-to-scene distance so snaps still work in
                # test mode.
                thr_scene = 12.0
            box = QtCore.QRectF(p.x() - thr_scene, p.y() - thr_scene, thr_scene * 2, thr_scene * 2)
            _best = None
            _best_d = 1e18
            items = list(self.scene().items(box))
            if _logger.isEnabledFor(10):
                try:
                    _logger.debug("_compute_osnap: %d items in search box", len(items))
                except Exception:
                    _logger.debug("_compute_osnap: items present (count unknown)")
            # First pass: endpoint/mid/center
            cand = []
            for it in items:
                # skip overlay helpers
                if it is self.osnap_marker:
                    continue
                pts = []
                if _logger.isEnabledFor(10):
                    try:
                        _logger.debug("  examining item: %r", it)
                    except Exception:
                        pass
                # Prefer line endpoints if the item exposes a numeric .line();
                # otherwise fall back to rect.center (ellipse-like).
                handled = False
                tried_line = False
                if hasattr(it, "line") and callable(getattr(it, "line")):
                    try:
                        l = it.line()
                        if _logger.isEnabledFor(10):
                            _logger.debug("    line() -> %r", l)
                        # If the returned object is already a QLineF, use it
                        # directly. If it's a Mock, skip and let rect/path try.
                        if isinstance(l, QtCore.QLineF):
                            x1 = l.x1()
                            y1 = l.y1()
                            x2 = l.x2()
                            y2 = l.y2()
                        elif isinstance(l, Mock):
                            tried_line = True
                            if _logger.isEnabledFor(10):
                                _logger.debug("    line() returned Mock, will try rect/path")
                            raise TypeError("mock-line")
                        else:
                            x1 = float(l.x1())
                            y1 = float(l.y1())
                            x2 = float(l.x2())
                            y2 = float(l.y2())
                    except Exception:
                        _tried_line = True
                        if _logger.isEnabledFor(10):
                            _logger.debug("    line() returned non-numeric, will try rect/path")
                    else:
                        handled = True
                        if self.osnap_end:
                            pts += [QtCore.QPointF(x1, y1), QtCore.QPointF(x2, y2)]
                        if self.osnap_mid:
                            pts += [QtCore.QPointF((x1 + x2) / 2.0, (y1 + y2) / 2.0)]
                if not handled and hasattr(it, "rect") and callable(getattr(it, "rect")):
                    if self.osnap_center:
                        try:
                            r = it.rect()
                            if _logger.isEnabledFor(10):
                                _logger.debug("    rect() -> %r", r)
                            center = r.center()
                            # If the center is a Mock, it's likely an artifact of
                            # a patched Qt class in tests — skip it.
                            if isinstance(center, Mock):
                                if _logger.isEnabledFor(10):
                                    _logger.debug("    rect.center is Mock, skipping")
                                raise TypeError("mock-center")
                            cx = float(center.x())
                            cy = float(center.y())
                        except Exception:
                            if _logger.isEnabledFor(10):
                                _logger.debug("    rect.center non-numeric, skipping")
                        else:
                            handled = True
                            if _logger.isEnabledFor(10):
                                _logger.debug(
                                    "    rect.center -> %r (x=%r,y=%r) type=%r",
                                    center,
                                    cx,
                                    cy,
                                    type(center),
                                )
                            pts = [QtCore.QPointF(cx, cy)]
                if not handled and hasattr(it, "path") and callable(getattr(it, "path")):
                    pth = it.path()
                    n = pth.elementCount()
                    if n >= 1 and (self.osnap_end or self.osnap_mid):
                        e0 = pth.elementAt(0)
                        eN = pth.elementAt(n - 1)
                        if self.osnap_end:
                            pts += [QtCore.QPointF(e0.x, e0.y), QtCore.QPointF(eN.x, eN.y)]
                        if self.osnap_mid and n >= 2:
                            e1 = pth.elementAt(1)
                            pts += [QtCore.QPointF((e0.x + e1.x) / 2.0, (e0.y + e1.y) / 2.0)]
                for q in pts:
                    try:
                        d = QtCore.QLineF(p, q).length()
                    except Exception:
                        continue
                    if d <= thr_scene:
                        cand.append((d, q))
            # Intersection snaps between nearby lines
            if _logger.isEnabledFor(10):
                _logger.debug(
                    "  before intersection: thr_scene=%r cand_count=%d", thr_scene, len(cand)
                )
            if self.osnap_intersect:
                # Build a list of real QLineF objects from items whose
                # .line() returns numeric coordinates; skip mocks that
                # expose .line() but don't return a real line.
                line_qs = []
                for it in items:
                    if not (hasattr(it, "line") and callable(getattr(it, "line"))):
                        continue
                    try:
                        lraw = it.line()
                        lq = QtCore.QLineF(lraw)
                        # ensure numeric coords
                        _ = float(lq.x1())
                    except Exception:
                        if _logger.isEnabledFor(10):
                            _logger.debug("  skipping item for intersection: %r", it)
                        continue
                    line_qs.append(lq)
                # debug info via logger about built numeric segments
                if _logger.isEnabledFor(10):
                    try:
                        _logger.debug("  built numeric segments count=%d", len(line_qs))
                    except Exception:
                        _logger.debug("  built numeric segments present")
                n = len(line_qs)
                for i in range(n):
                    li = line_qs[i]
                    for j in range(i + 1, n):
                        lj = line_qs[j]
                        # Use logger instead of prints for intersection tracing
                        if _logger.isEnabledFor(10):
                            try:
                                _logger.debug("    intersect candidate li=%r lj=%r", li, lj)
                            except Exception:
                                _logger.debug("    intersect candidate present")
                        # Try the native QLineF.intersect first; if it reports
                        # no intersection (or raises), fall back to a pure-Python
                        # segment intersection for determinism in tests.
                        ip = QtCore.QPointF()
                        try:
                            res = li.intersect(lj, ip)
                        except Exception:
                            res = QtCore.QLineF.NoIntersection

                        if res == QtCore.QLineF.NoIntersection:
                            # numeric fallback
                            def _seg_intersect(a1, a2, b1, b2):
                                x1, y1 = a1
                                x2, y2 = a2
                                x3, y3 = b1
                                x4, y4 = b2
                                denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
                                if abs(denom) < 1e-9:
                                    return None
                                px = (
                                    (x1 * y2 - y1 * x2) * (x3 - x4)
                                    - (x1 - x2) * (x3 * y4 - y3 * x4)
                                ) / denom
                                py = (
                                    (x1 * y2 - y1 * x2) * (y3 - y4)
                                    - (y1 - y2) * (x3 * y4 - y3 * x4)
                                ) / denom

                                def _within(x, a, b):
                                    lo = min(a, b) - 1e-9
                                    hi = max(a, b) + 1e-9
                                    return lo <= x <= hi

                                if not (
                                    _within(px, x1, x2)
                                    and _within(py, y1, y2)
                                    and _within(px, x3, x4)
                                    and _within(py, y3, y4)
                                ):
                                    return None
                                return QtCore.QPointF(px, py)

                            ax1, ay1, ax2, ay2 = li.x1(), li.y1(), li.x2(), li.y2()
                            bx1, by1, bx2, by2 = lj.x1(), lj.y1(), lj.x2(), lj.y2()
                            num_ip = _seg_intersect((ax1, ay1), (ax2, ay2), (bx1, by1), (bx2, by2))
                            if num_ip is not None:
                                ip = num_ip
                                res = QtCore.QLineF.BoundedIntersection

                        if _logger.isEnabledFor(10):
                            try:
                                _logger.debug(
                                    "    intersect li=%r lj=%r -> res=%r ip=%r", li, lj, res, ip
                                )
                            except Exception:
                                _logger.debug("    intersect computed (unable to print values)")

                        if res != QtCore.QLineF.NoIntersection:
                            d = QtCore.QLineF(p, ip).length()
                            if d <= thr_scene:
                                if _logger.isEnabledFor(10):
                                    try:
                                        _logger.debug(
                                            "    add intersection candidate li=%r lj=%r -> (d=%r ip=%r)",
                                            li,
                                            lj,
                                            d,
                                            ip,
                                        )
                                    except Exception:
                                        _logger.debug(
                                            "    add intersection candidate (unable to print)"
                                        )
                                cand.append((d, ip))
            # Perpendicular from point to line
            if self.osnap_perp:
                for it in items:
                    if not (hasattr(it, "line") and callable(getattr(it, "line"))):
                        continue
                    l = QtCore.QLineF(it.line())
                    # project point onto line segment
                    ax, ay, bx, by = l.x1(), l.y1(), l.x2(), l.y2()
                    vx, vy = bx - ax, by - ay
                    wx, wy = p.x() - ax, p.y() - ay
                    denom = vx * vx + vy * vy
                    if denom <= 1e-6:
                        continue
                    t = (wx * vx + wy * vy) / denom
                    if 0.0 <= t <= 1.0:
                        qx, qy = ax + t * vx, ay + t * vy
                        qpt = QtCore.QPointF(qx, qy)
                        d = QtCore.QLineF(p, qpt).length()
                        if d <= thr_scene:
                            cand.append((d, qpt))
            # Sort candidates by distance and deduplicate
            cand.sort(key=lambda x: x[0])
            if _logger.isEnabledFor(10):
                try:
                    _logger.debug(
                        "  candidates (pre-uniq): %s",
                        [(round(d, 3), (q.x(), q.y())) for d, q in cand],
                    )
                except Exception:
                    _logger.debug("  candidates present (pre-uniq)")
            uniq = []
            seen = set()
            for _, q in cand:
                key = (round(q.x(), 2), round(q.y(), 2))
                if key in seen:
                    continue
                seen.add(key)
                uniq.append(q)
            self._snap_candidates = uniq
            self._snap_index = 0
            return uniq[0] if uniq else None
        except Exception:
            return None

    def _apply_osnap(self, p: QPointF) -> QtCore.QPointF:
        sp = QtCore.QPointF(p)
        q = None
        # In paper space, skip object snaps and grid snap entirely
        try:
            if getattr(self.win, "in_paper_space", False):
                self.osnap_marker.setVisible(False)
                return sp
        except Exception:
            pass
        if self.osnap_end or self.osnap_mid or self.osnap_center:
            q = self._compute_osnap(sp)
        if q is None:
            # Use scene snap only if available (GridScene in model space)
            try:
                sc = self.scene()
                if hasattr(sc, "snap") and callable(getattr(sc, "snap")):
                    sp = sc.snap(sp)
            except Exception:
                pass
            self.osnap_marker.setVisible(False)
            return sp
        else:
            self.osnap_marker.setPos(q)
            self.osnap_marker.setVisible(True)
            return q

    def set_current_device(self, proto: dict):
        self.current_proto = proto

        # Debug: log concise proto info for tracing placement
        try:
            keys = list(proto.keys()) if isinstance(proto, dict) else []
            _logger.debug(
                "set_current_device proto_keys=%s kind_guess=%s", keys[:8], infer_device_kind(proto)
            )
        except Exception:
            _logger.debug("set_current_device proto=<unprintable>")
        self.current_kind = infer_device_kind(proto)
        self._ensure_ghost()

    def _ensure_ghost(self):
        # clear if not a coverage-driven type
        if not self.current_proto or self.current_kind not in ("strobe", "speaker", "smoke"):
            if self.ghost:
                self.scene().removeItem(self.ghost)
                self.ghost = None
            return
        if not self.ghost:
            d = self.current_proto
            self.ghost = DeviceItem(
                0, 0, d["symbol"], d["name"], d.get("manufacturer", ""), d.get("part_number", "")
            )
            self.ghost.setOpacity(0.65)
            self.ghost.setParentItem(self.overlay_group)
        # defaults
        ppf = float(self.win.px_per_ft)
        if self.current_kind == "strobe":
            diam_ft = float(self.win.prefs.get("default_strobe_diameter_ft", 50.0))
            self.ghost.set_coverage(
                {
                    "mode": "strobe",
                    "mount": "ceiling",
                    "computed_radius_ft": max(0.0, diam_ft / 2.0),
                    "px_per_ft": ppf,
                }
            )
        elif self.current_kind == "speaker":
            self.ghost.set_coverage(
                {
                    "mode": "speaker",
                    "mount": "ceiling",
                    "computed_radius_ft": 30.0,
                    "px_per_ft": ppf,
                }
            )
        elif self.current_kind == "smoke":
            spacing_ft = float(self.win.prefs.get("default_smoke_spacing_ft", 30.0))
            self.ghost.set_coverage(
                {
                    "mode": "smoke",
                    "mount": "ceiling",
                    "params": {"spacing_ft": spacing_ft},
                    "computed_radius_ft": spacing_ft / 2.0,
                    "px_per_ft": ppf,
                }
            )
        # placement coverage toggle
        self.ghost.set_coverage_enabled(bool(self.win.prefs.get("show_placement_coverage", True)))

    def _update_crosshair(self, sp: QPointF):
        if not getattr(self, "show_crosshair", True):
            return
        rect = self.scene().sceneRect()
        self.cross_v.setLine(sp.x(), rect.top(), sp.x(), rect.bottom())
        self.cross_h.setLine(rect.left(), sp.y(), rect.right(), sp.y())
        dx_ft = sp.x() / self.win.px_per_ft
        dy_ft = sp.y() / self.win.px_per_ft
        # Append draw info if applicable
        draw_info = ""
        try:
            if getattr(self.win, "draw", None) and getattr(self.win.draw, "points", None):
                pts = self.win.draw.points
                if pts:
                    p0 = pts[-1]
                    vec = QtCore.QLineF(p0, sp)
                    length_ft = vec.length() / self.win.px_per_ft
                    ang = vec.angle()  # 0 to 360 CCW from +x in Qt
                    draw_info = f"  len={length_ft:.2f} ft  ang={ang:.1f}Â°"
        except Exception:
            pass
        self.win.statusBar().showMessage(
            f"x={dx_ft:.2f} ft   y={dy_ft:.2f} ft   scale={self.win.px_per_ft:.2f} px/ft  snap={self.win.snap_label}{draw_info}"
        )

    def wheelEvent(self, e: QtGui.QWheelEvent):
        s = 1.15 if e.angleDelta().y() > 0 else 1 / 1.15
        self.scale(s, s)

    def keyPressEvent(self, e: QtGui.QKeyEvent):
        k = e.key()
        if k == Qt.Key_Space:
            self.setDragMode(QGraphicsView.ScrollHandDrag)
            self.setCursor(Qt.OpenHandCursor)
            e.accept()
            return
        if k == Qt.Key_Shift:
            self.ortho = True
            e.accept()
            return
        # Crosshair toggle moved to 'X' (keyboard shortcut handled in MainWindow too)
        if k == Qt.Key_Escape:
            self.win.cancel_active_tool()
            e.accept()
            return
        if k == Qt.Key_Tab:
            # cycle snap candidates
            if getattr(self, "_snap_candidates", None):
                self._snap_index = (self._snap_index + 1) % len(self._snap_candidates)
                q = self._snap_candidates[self._snap_index]
                self.osnap_marker.setPos(q)
                self.osnap_marker.setVisible(True)
                e.accept()
                return
        super().keyPressEvent(e)

    def keyReleaseEvent(self, e: QtGui.QKeyEvent):
        k = e.key()
        if k == Qt.Key_Space:
            self.setDragMode(QGraphicsView.RubberBandDrag)
            self.unsetCursor()
            e.accept()
            return
        if k == Qt.Key_Shift:
            self.ortho = False
            e.accept()
            return
        super().keyReleaseEvent(e)

    def mouseMoveEvent(self, e: QtGui.QMouseEvent):
        # Middle-mouse panning (standard CAD feel)
        if self._mmb_panning:
            dx = e.position().x() - self._mmb_last.x()
            dy = e.position().y() - self._mmb_last.y()
            self._mmb_last = e.position()
            h = self.horizontalScrollBar()
            v = self.verticalScrollBar()
            h.setValue(h.value() - int(dx))
            v.setValue(v.value() - int(dy))
            e.accept()
            return

        sp = self.mapToScene(e.position().toPoint())
        sp = self._apply_osnap(sp)
        self.last_scene_pos = sp
        self._update_crosshair(sp)
        if getattr(self.win, "draw", None):
            try:
                self.win.draw.on_mouse_move(sp, shift_ortho=self.ortho)
            except Exception:
                pass
        if getattr(self.win, "dim_tool", None):
            try:
                self.win.dim_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "text_tool", None):
            try:
                self.win.text_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "mtext_tool", None) and getattr(self.win.mtext_tool, "active", False):
            try:
                self.win.mtext_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "freehand_tool", None) and getattr(
            self.win.freehand_tool, "active", False
        ):
            try:
                self.win.freehand_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "measure_tool", None) and getattr(
            self.win.measure_tool, "active", False
        ):
            try:
                self.win.measure_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "leader_tool", None) and getattr(
            self.win.leader_tool, "active", False
        ):
            try:
                self.win.leader_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "cloud_tool", None) and getattr(self.win.cloud_tool, "active", False):
            try:
                self.win.cloud_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "trim_tool", None) and getattr(self.win.trim_tool, "active", False):
            try:
                self.win.trim_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "extend_tool", None) and getattr(
            self.win.extend_tool, "active", False
        ):
            try:
                self.win.extend_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "fillet_tool", None) and getattr(
            self.win.fillet_tool, "active", False
        ):
            try:
                self.win.fillet_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "fillet_radius_tool", None) and getattr(
            self.win.fillet_radius_tool, "active", False
        ):
            try:
                self.win.fillet_radius_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "move_tool", None) and getattr(self.win.move_tool, "active", False):
            try:
                self.win.move_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "underlay_drag_tool", None) and getattr(
            self.win.underlay_drag_tool, "active", False
        ):
            try:
                self.win.underlay_drag_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "rotate_tool", None) and getattr(
            self.win.rotate_tool, "active", False
        ):
            try:
                self.win.rotate_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "mirror_tool", None) and getattr(
            self.win.mirror_tool, "active", False
        ):
            try:
                self.win.mirror_tool.on_mouse_move(sp)
            except Exception:
                pass
        if getattr(self.win, "scale_tool", None) and getattr(self.win.scale_tool, "active", False):
            try:
                self.win.scale_tool.on_mouse_move(sp)
            except Exception:
                pass
        if self.ghost:
            self.ghost.setPos(sp)
        super().mouseMoveEvent(e)

    def mousePressEvent(self, e: QtGui.QMouseEvent):
        win = self.win
        sp = self._apply_osnap(self.mapToScene(e.position().toPoint()))
        # If we're in hand-drag mode (Space held), defer to QGraphicsView to pan
        if self.dragMode() == QGraphicsView.ScrollHandDrag:
            return super().mousePressEvent(e)
        # Middle mouse starts panning regardless of mode
        if e.button() == Qt.MiddleButton:
            self._mmb_panning = True
            self._mmb_last = e.position()
            self.setCursor(Qt.ClosedHandCursor)
            e.accept()
            return
        if e.button() == Qt.LeftButton:
            if getattr(win, "draw", None) and getattr(win.draw, "mode", 0) != 0:
                try:
                    if win.draw.on_click(sp, shift_ortho=self.ortho):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "dim_tool", None) and getattr(win.dim_tool, "active", False):
                try:
                    if win.dim_tool.on_click(sp):
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "text_tool", None) and getattr(win.text_tool, "active", False):
                try:
                    if win.text_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "mtext_tool", None) and getattr(win.mtext_tool, "active", False):
                try:
                    if win.mtext_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "freehand_tool", None) and getattr(win.freehand_tool, "active", False):
                try:
                    # freehand starts on press; release will commit
                    if win.freehand_tool.on_press(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "leader_tool", None) and getattr(win.leader_tool, "active", False):
                try:
                    if win.leader_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "cloud_tool", None) and getattr(win.cloud_tool, "active", False):
                try:
                    if win.cloud_tool.on_click(sp):
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "measure_tool", None) and getattr(win.measure_tool, "active", False):
                try:
                    if win.measure_tool.on_click(sp):
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "trim_tool", None) and getattr(win.trim_tool, "active", False):
                try:
                    if win.trim_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "extend_tool", None) and getattr(win.extend_tool, "active", False):
                try:
                    if win.extend_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "fillet_tool", None) and getattr(win.fillet_tool, "active", False):
                try:
                    if win.fillet_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "move_tool", None) and getattr(win.move_tool, "active", False):
                try:
                    if win.move_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "rotate_tool", None) and getattr(win.rotate_tool, "active", False):
                try:
                    if win.rotate_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "mirror_tool", None) and getattr(win.mirror_tool, "active", False):
                try:
                    if win.mirror_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "scale_tool", None) and getattr(win.scale_tool, "active", False):
                try:
                    if win.scale_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "chamfer_tool", None) and getattr(win.chamfer_tool, "active", False):
                try:
                    if win.chamfer_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "underlay_drag_tool", None) and getattr(
                win.underlay_drag_tool, "active", False
            ):
                try:
                    if win.underlay_drag_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(win, "fillet_radius_tool", None) and getattr(
                win.fillet_radius_tool, "active", False
            ):
                try:
                    if win.fillet_radius_tool.on_click(sp):
                        win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            # Prefer selection when clicking over existing selectable content
            try:
                under_items = self.items(e.position().toPoint())
                for it in under_items:
                    if it in (self.cross_v, self.cross_h, self.osnap_marker):
                        continue
                    if isinstance(it, QtWidgets.QGraphicsItem) and (
                        it.flags() & QtWidgets.QGraphicsItem.ItemIsSelectable
                    ):
                        return super().mousePressEvent(e)
            except Exception:
                pass
            if self.current_proto:
                d = self.current_proto

                # Debug: log proto summary and active layer to trace placement
                try:
                    import json as _json

                    _logger.debug(
                        "placing proto=%s",
                        _json.dumps(
                            {k: d.get(k) for k in ("symbol", "name", "manufacturer", "part_number")}
                        ),
                    )
                except Exception:
                    _logger.debug("placing proto=<unserializable>")
                try:
                    _logger.debug("active_layer_id=%s", getattr(self.win, "active_layer_id", None))
                except Exception:
                    pass
                try:
                    _logger.debug("ghost_present=%s kind=%s", bool(self.ghost), self.current_kind)
                except Exception:
                    pass
                layer_obj = next(
                    (l for l in self.win.layers if l["id"] == self.win.active_layer_id), None
                )
                it = DeviceItem(
                    sp.x(),
                    sp.y(),
                    d["symbol"],
                    d["name"],
                    d.get("manufacturer", ""),
                    d.get("part_number", ""),
                    layer_obj,
                )
                if self.ghost and self.current_kind in ("strobe", "speaker", "smoke"):
                    it.set_coverage(self.ghost.coverage)
                # Respect global overlay toggle on placement
                try:
                    it.set_coverage_enabled(bool(self.win.show_coverage))
                except Exception:
                    pass
                it.setParentItem(self.devices_group)
                win.push_history()
                e.accept()
                return
            else:
                # Clear selection when clicking empty space with no active tool
                self.scene().clearSelection()
        elif e.button() == Qt.RightButton:
            win.canvas_menu(e.globalPosition().toPoint())
            e.accept()
            return
        super().mousePressEvent(e)

    def mouseReleaseEvent(self, e: QtGui.QMouseEvent):
        if e.button() == Qt.MiddleButton and self._mmb_panning:
            self._mmb_panning = False
            self.unsetCursor()
            e.accept()
            return
        # If hand-drag mode (Space), let base handle release
        if self.dragMode() == QGraphicsView.ScrollHandDrag:
            return super().mouseReleaseEvent(e)
        if e.button() == Qt.LeftButton:
            if getattr(self.win, "freehand_tool", None) and getattr(
                self.win.freehand_tool, "active", False
            ):
                try:
                    if self.win.freehand_tool.on_release(self.last_scene_pos):
                        self.win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
            if getattr(self.win, "cloud_tool", None) and getattr(
                self.win.cloud_tool, "active", False
            ):
                try:
                    if self.win.cloud_tool.finish():
                        self.win.push_history()
                        e.accept()
                        return
                except Exception:
                    pass
        super().mouseReleaseEvent(e)


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        # Ensure basic mutable structures exist immediately. Some tools
        # or simulated events may call push_history during init, so make
        # sure these attributes are present as soon as the object is created.
        self.history = []
        self.history_index = -1
        self.setWindowTitle(APP_TITLE)
        self.resize(1400, 900)
        self.prefs = load_prefs()
        self.px_per_ft = float(self.prefs.get("px_per_ft", 12.0))
        self.snap_label = self.prefs.get("snap_label", "grid")
        self.snap_step_in = float(self.prefs.get("snap_step_in", 0.0))
        self.prefs.setdefault("default_strobe_diameter_ft", 50.0)
        self.prefs.setdefault("default_smoke_spacing_ft", 30.0)
        self.prefs.setdefault("grid_opacity", 0.25)
        self.prefs.setdefault("grid_width_px", 0.0)
        self.prefs.setdefault("grid_major_every", 5)
        self.prefs.setdefault("print_in_per_ft", 0.125)
        self.prefs.setdefault("print_dpi", 300)
        self.prefs.setdefault("page_size", "Letter")
        self.prefs.setdefault("page_orient", "Landscape")
        self.prefs.setdefault("page_margin_in", 0.5)
        self.prefs.setdefault("show_placement_coverage", True)
        save_prefs(self.prefs)

        # Initialize global database connection for coverage calculations
        from db import connection

        connection.initialize_database(in_memory=True)

        # Theme
        self.set_theme(self.prefs.get("theme", "dark"))  # apply early

        self.devices_all = catalog.load_catalog()
        # Minimal device tree so headless simulators can find and use it.
        try:
            self.device_tree = QtWidgets.QTreeWidget()
            self.device_tree.setHeaderLabels(["Devices"])
            self.device_tree.setAlternatingRowColors(True)
            self.device_tree.setSortingEnabled(True)
            try:
                self.device_tree.sortByColumn(0, Qt.AscendingOrder)
            except Exception:
                pass
            # Minimal population so headless sims can find devices
            try:
                # Group devices by type for a small hierarchy
                grouped = {}
                for d in self.devices_all:
                    cat = d.get("type", "Unknown") or "Unknown"
                    grouped.setdefault(cat, []).append(d)
                for cat in sorted(grouped.keys()):
                    cat_item = QtWidgets.QTreeWidgetItem([cat])
                    for dev in sorted(grouped[cat], key=lambda x: x.get("name", "")):
                        txt = f"{dev.get('name','<unknown>')} ({dev.get('symbol','')})"
                        if dev.get("part_number"):
                            txt += f" - {dev.get('part_number')}"
                        it = QtWidgets.QTreeWidgetItem([txt])
                        it.setData(0, QtCore.Qt.UserRole, dev)
                        cat_item.addChild(it)
                    self.device_tree.addTopLevelItem(cat_item)
                self.device_tree.expandAll()
            except Exception:
                pass
        except Exception:
            # If Qt widgets are not fully usable in this environment, leave a None
            # and let callers fall back. Simulators check for presence.
            self.device_tree = None
        # Ensure we have an active layer id and layer list available early.
        # Some headless runners create the MainWindow and call placement
        # routines before the full DB wiring is complete. Provide a safe
        # fallback so placement can proceed in tests and CI.
        self.prefs.setdefault("active_layer_id", 1)
        self.active_layer_id = self.prefs["active_layer_id"]
        try:
            from db import loader as db_loader

            self.layers = db_loader.fetch_layers(db_loader.connect())
        except Exception:
            # Minimal fallback layer so placement code has something to reference.
            self.layers = [{"id": 1, "name": "Default", "visible": True}]

        self.scene = GridScene(int(self.prefs.get("grid", DEFAULT_GRID_SIZE)), 0, 0, 15000, 10000)
        self.scene.snap_enabled = bool(self.prefs.get("snap", True))
        self.scene.set_grid_style(
            float(self.prefs.get("grid_opacity", 0.25)),
            float(self.prefs.get("grid_width_px", 0.0)),
            int(self.prefs.get("grid_major_every", 5)),
        )
        self._apply_snap_step_from_inches(self.snap_step_in)

        self.layer_underlay = QtWidgets.QGraphicsItemGroup()
        self.layer_underlay.setZValue(-50)
        self.scene.addItem(self.layer_underlay)
        self.layer_sketch = QtWidgets.QGraphicsItemGroup()
        self.layer_sketch.setZValue(40)
        self.scene.addItem(self.layer_sketch)
        self.layer_wires = QtWidgets.QGraphicsItemGroup()
        self.layer_wires.setZValue(60)
        self.scene.addItem(self.layer_wires)
        self.layer_devices = QtWidgets.QGraphicsItemGroup()
        self.layer_devices.setZValue(100)
        self.scene.addItem(self.layer_devices)
        self.layer_overlay = QtWidgets.QGraphicsItemGroup()
        self.layer_overlay.setZValue(200)
        self.scene.addItem(self.layer_overlay)
        # Allow child items to receive mouse events for selection and dragging
        for grp in (
            self.layer_underlay,
            self.layer_sketch,
            self.layer_wires,
            self.layer_devices,
            self.layer_overlay,
        ):
            try:
                grp.setHandlesChildEvents(False)
            except Exception:
                pass

        self.view = CanvasView(
            self.scene,
            self.layer_devices,
            self.layer_wires,
            self.layer_sketch,
            self.layer_overlay,
            self,
        )
        # Distinguish model space visually
        try:
            self.view.setBackgroundBrush(QtGui.QColor(20, 22, 26))
        except Exception:
            pass
        self.page_frame = None
        self.title_block = None
        # DXF layers placeholder used by serialize_state; ensure exists early
        self._dxf_layers = {}
        # Sheet manager: list of {name, scene}; paper_scene points to current sheet
        self.sheets = []
        self.paper_scene = None
        self.in_paper_space = False
        # Auto-add a default page frame on first run (can be removed via Layout menu)
        if bool(self.prefs.setdefault("auto_page_frame", True)):
            try:
                pf = PageFrame(
                    self.px_per_ft,
                    size_name=self.prefs.get("page_size", "Letter"),
                    orientation=self.prefs.get("page_orient", "Landscape"),
                    margin_in=self.prefs.get("page_margin_in", 0.5),
                )
                pf.setParentItem(self.layer_underlay)
                self.page_frame = pf
            except Exception:
                pass

        # CAD tools
        self.draw = draw_tools.DrawController(self, self.layer_sketch)
        self.dim_tool = DimensionTool(self, self.layer_overlay)
        self.text_tool = TextTool(self, self.layer_sketch)
        self.mtext_tool = MTextTool(self, self.layer_sketch)
        self.freehand_tool = FreehandTool(self, self.layer_sketch)
        self.underlay_ref_tool = ScaleUnderlayRefTool(self, self.layer_underlay)
        self.underlay_drag_tool = ScaleUnderlayDragTool(self, self.layer_underlay)
        self.leader_tool = LeaderTool(self, self.layer_overlay)
        self.cloud_tool = RevisionCloudTool(self, self.layer_overlay)
        self.trim_tool = TrimTool(self)
        self.extend_tool = ExtendTool(self)
        self.fillet_tool = FilletTool(self)
        self.measure_tool = MeasureTool(self, self.layer_overlay)
        self.move_tool = MoveTool(self)
        self.rotate_tool = RotateTool(self)

        # Try to attach enhanced menu methods and menu enhancements if available.
        try:
            from app import enhanced_menus

            try:
                enhanced_menus.add_main_window_methods(self.__class__)
            except Exception:
                pass
            try:
                enhanced_menus.enhance_menus(self)
            except Exception:
                pass
        except Exception:
            # It's OK if enhanced_menus is not present; fall back to defaults
            pass
        self.mirror_tool = MirrorTool(self)
        self.scale_tool = ScaleTool(self)
        self.chamfer_tool = ChamferTool(self)
        self.fillet_radius_tool = FilletRadiusTool(self, self.layer_sketch)

        # Menus
        menubar = self.menuBar()
        m_file = menubar.addMenu("&File")
        m_file.addAction("New", self.new_project, QtGui.QKeySequence.New)
        m_file.addAction("Openâ€¦", self.open_project, QtGui.QKeySequence.Open)
        m_file.addAction("Save Asâ€¦", self.save_project_as, QtGui.QKeySequence.SaveAs)
        m_file.addSeparator()
        imp = m_file.addMenu("Import")
        imp.addAction("DXF Underlayâ€¦", self.import_dxf_underlay)
        imp.addAction("PDF Underlayâ€¦", self.import_pdf_underlay)
        exp = m_file.addMenu("Export")
        exp.addAction("PNGâ€¦", self.export_png)
        exp.addAction("PDFâ€¦", self.export_pdf)
        exp.addAction("Device Schedule (CSV)â€¦", self.export_device_schedule_csv)
        exp.addAction("Place Symbol Legend", self.place_symbol_legend)
        # Settings submenu (moved under File)
        m_settings = m_file.addMenu("Settings")
        theme = m_settings.addMenu("Theme")
        theme.addAction("Dark", lambda: self.set_theme("dark"))
        theme.addAction("Light", lambda: self.set_theme("light"))
        theme.addAction("High Contrast (Dark)", lambda: self.set_theme("high_contrast"))
        m_file.addSeparator()
        m_file.addAction("Quit", self.close, QtGui.QKeySequence.Quit)

        # Edit menu
        m_edit = menubar.addMenu("&Edit")
        act_undo = QtGui.QAction("Undo", self)
        act_undo.setShortcut(QtGui.QKeySequence.Undo)
        act_undo.triggered.connect(self.undo)
        m_edit.addAction(act_undo)
        act_redo = QtGui.QAction("Redo", self)
        act_redo.setShortcut(QtGui.QKeySequence.Redo)
        act_redo.triggered.connect(self.redo)
        m_edit.addAction(act_redo)
        m_edit.addSeparator()
        act_del = QtGui.QAction("Delete", self)
        act_del.setShortcut(Qt.Key_Delete)
        act_del.triggered.connect(self.delete_selection)
        m_edit.addAction(act_del)

        m_tools = menubar.addMenu("&Tools")

        def add_tool(name, cb):
            act = QtGui.QAction(name, self)
            act.triggered.connect(cb)
            m_tools.addAction(act)
            return act

        self.act_draw_line = add_tool(
            "Draw Line",
            lambda: (
                setattr(self.draw, "layer", self.layer_sketch),
                self.draw.set_mode(draw_tools.DrawMode.LINE),
            ),
        )
        self.act_draw_rect = add_tool(
            "Draw Rect",
            lambda: (
                setattr(self.draw, "layer", self.layer_sketch),
                self.draw.set_mode(draw_tools.DrawMode.RECT),
            ),
        )
        self.act_draw_circle = add_tool(
            "Draw Circle",
            lambda: (
                setattr(self.draw, "layer", self.layer_sketch),
                self.draw.set_mode(draw_tools.DrawMode.CIRCLE),
            ),
        )
        self.act_draw_poly = add_tool(
            "Draw Polyline",
            lambda: (
                setattr(self.draw, "layer", self.layer_sketch),
                self.draw.set_mode(draw_tools.DrawMode.POLYLINE),
            ),
        )
        self.act_draw_arc3 = add_tool(
            "Draw Arc (3-Point)",
            lambda: (
                setattr(self.draw, "layer", self.layer_sketch),
                self.draw.set_mode(draw_tools.DrawMode.ARC3),
            ),
        )
        self.act_draw_wire = add_tool("Draw Wire", lambda: self._set_wire_mode())
        self.act_text = add_tool("Text", self.start_text)
        self.act_mtext = add_tool("MText", self.start_mtext)
        self.act_freehand = add_tool("Freehand", self.start_freehand)
        self.act_leader = add_tool("Leader", self.start_leader)
        self.act_cloud = add_tool("Revision Cloud", self.start_cloud)
        m_tools.addSeparator()
        m_tools.addAction("Dimension (D)", self.start_dimension)
        m_tools.addAction("Measure (M)", self.start_measure)

        # (Settings moved under File)

        # Layout / Paper Space
        m_layout = menubar.addMenu("&Layout")
        m_layout.addAction("Add Page Frameâ€¦", self.add_page_frame)
        m_layout.addAction("Remove Page Frame", self.remove_page_frame)
        m_layout.addAction("Add/Update Title Blockâ€¦", self.add_or_update_title_block)
        m_layout.addAction("Page Setupâ€¦", self.page_setup_dialog)
        m_layout.addAction("Add Viewport", self.add_viewport)
        m_layout.addSeparator()
        m_layout.addAction("Switch to Paper Space", lambda: self.toggle_paper_space(True))
        m_layout.addAction("Switch to Model Space", lambda: self.toggle_paper_space(False))
        scale_menu = m_layout.addMenu("Print Scale")

        def add_scale(label, inches_per_ft):
            act = QtGui.QAction(label, self)
            act.triggered.connect(lambda v=inches_per_ft: self.set_print_scale(v))
            scale_menu.addAction(act)

        for lbl, v in [
            ("1/16\" = 1'", 1.0 / 16.0),
            ("3/32\" = 1'", 3.0 / 32.0),
            ("1/8\" = 1'", 1.0 / 8.0),
            ("3/16\" = 1'", 3.0 / 16.0),
            ("1/4\" = 1'", 0.25),
            ("3/8\" = 1'", 0.375),
            ("1/2\" = 1'", 0.5),
            ("1\" = 1'", 1.0),
        ]:
            add_scale(lbl, v)
        scale_menu.addAction("Customâ€¦", self.set_print_scale_custom)
        # Status bar: left space selector/lock; right badges
        self.space_combo = QtWidgets.QComboBox()
        self.space_combo.addItems(["Model", "Paper"])
        self.space_combo.setCurrentIndex(0)
        self.space_lock = QtWidgets.QToolButton()
        self.space_lock.setCheckable(True)
        self.space_lock.setText("Lock")
        self.statusBar().addWidget(QtWidgets.QLabel("Space:"))
        self.statusBar().addWidget(self.space_combo)
        self.statusBar().addWidget(self.space_lock)
        self.space_combo.currentIndexChanged.connect(self._on_space_combo_changed)
        # Right badges
        self.scale_badge = QtWidgets.QLabel("")
        self.scale_badge.setStyleSheet("QLabel { color: #c0c0c0; }")
        self.statusBar().addPermanentWidget(self.scale_badge)
        self.space_badge = QtWidgets.QLabel("MODEL SPACE")
        self.space_badge.setStyleSheet("QLabel { color: #7dcfff; font-weight: bold; }")
        self.statusBar().addPermanentWidget(self.space_badge)
        self._init_sheet_manager()

    def _on_space_combo_changed(self, idx: int):
        if self.space_lock.isChecked():
            # Revert change if locked
            try:
                self.space_combo.blockSignals(True)
                self.space_combo.setCurrentIndex(1 if self.in_paper_space else 0)
            finally:
                self.space_combo.blockSignals(False)
            return
        # 0 = Model, 1 = Paper
        # Toggle the current space; menu construction should happen once at init,
        # not every time the user switches the space. Avoid referencing local
        # variables here which may not be in scope.
        self.toggle_paper_space(idx == 1)

        # Modify menu
        m_modify = menubar.addMenu("&Modify")
        m_modify.addAction("Offset Selectedâ€¦", self.offset_selected_dialog)
        m_modify.addAction("Trim Lines", self.start_trim)
        m_modify.addAction("Finish Trim", self.finish_trim)
        m_modify.addAction("Extend Lines", self.start_extend)
        m_modify.addAction("Fillet (Corner)", self.start_fillet)
        m_modify.addAction("Fillet (Radius)â€¦", self.start_fillet_radius)
        m_modify.addAction("Move", self.start_move)
        m_modify.addAction("Copy", self.start_copy)
        m_modify.addAction("Rotate", self.start_rotate)
        m_modify.addAction("Mirror", self.start_mirror)
        m_modify.addAction("Scale", self.start_scale)
        m_modify.addAction("Chamferâ€¦", self.start_chamfer)

        # Help menu
        m_help = menubar.addMenu("&Help")
        m_help.addAction("User Guide", self.show_user_guide)
        m_help.addAction("Keyboard Shortcuts", self.show_shortcuts)
        m_help.addSeparator()
        m_help.addAction("About Auto-Fire", self.show_about)

        m_view = menubar.addMenu("&View")
        self.act_view_grid = QtGui.QAction("Grid", self, checkable=True)
        self.act_view_grid.setChecked(True)
        self.act_view_grid.toggled.connect(self.toggle_grid)
        m_view.addAction(self.act_view_grid)
        self.act_view_snap = QtGui.QAction("Snap", self, checkable=True)
        self.act_view_snap.setChecked(self.scene.snap_enabled)
        self.act_view_snap.toggled.connect(self.toggle_snap)
        m_view.addAction(self.act_view_snap)
        self.act_view_cross = QtGui.QAction("Crosshair (X)", self, checkable=True)
        self.act_view_cross.setChecked(True)
        self.act_view_cross.toggled.connect(self.toggle_crosshair)
        m_view.addAction(self.act_view_cross)
        self.act_paperspace = QtGui.QAction("Paper Space Mode", self, checkable=True)
        self.act_paperspace.setChecked(False)
        self.act_paperspace.toggled.connect(self.toggle_paper_space)
        m_view.addAction(self.act_paperspace)
        self.show_coverage = bool(self.prefs.get("show_coverage", True))
        self.act_view_cov = QtGui.QAction("Show Device Coverage", self, checkable=True)
        self.act_view_cov.setChecked(self.show_coverage)
        self.act_view_cov.toggled.connect(self.toggle_coverage)
        m_view.addAction(self.act_view_cov)
        self.act_view_place_cov = QtGui.QAction(
            "Show Coverage During Placement", self, checkable=True
        )
        self.act_view_place_cov.setChecked(bool(self.prefs.get("show_placement_coverage", True)))
        self.act_view_place_cov.toggled.connect(self.toggle_placement_coverage)
        m_view.addAction(self.act_view_place_cov)
        m_view.addSeparator()
        act_scale = QtGui.QAction("Set Pixels per Footâ€¦", self)
        act_scale.triggered.connect(self.set_px_per_ft)
        m_view.addAction(act_scale)
        act_gridstyle = QtGui.QAction("Grid Styleâ€¦", self)
        act_gridstyle.triggered.connect(self.grid_style_dialog)
        m_view.addAction(act_gridstyle)
        # Quick snap step presets (guardrail: snap to fixed inch steps or grid)
        snap_menu = m_view.addMenu("Snap Step")

        def add_snap(label, inches):
            act = QtGui.QAction(label, self)
            act.triggered.connect(lambda v=inches: self.set_snap_inches(v))
            snap_menu.addAction(act)

        add_snap("Grid (default)", 0.0)
        add_snap("3 inches", 3.0)
        add_snap("6 inches", 6.0)
        add_snap("12 inches", 12.0)
        add_snap("24 inches", 24.0)

        # Object Snaps (OSNAP) toggles in View menu
        m_view.addSeparator()
        m_osnap = m_view.addMenu("Object Snaps")
        self.act_os_end = QtGui.QAction("Endpoint", self, checkable=True)
        self.act_os_mid = QtGui.QAction("Midpoint", self, checkable=True)
        self.act_os_cen = QtGui.QAction("Center", self, checkable=True)
        self.act_os_int = QtGui.QAction("Intersection", self, checkable=True)
        self.act_os_perp = QtGui.QAction("Perpendicular", self, checkable=True)
        self.act_os_end.setChecked(bool(self.prefs.get("osnap_end", True)))
        self.act_os_mid.setChecked(bool(self.prefs.get("osnap_mid", True)))
        self.act_os_cen.setChecked(bool(self.prefs.get("osnap_center", True)))
        self.act_os_int.setChecked(bool(self.prefs.get("osnap_intersect", True)))
        self.act_os_perp.setChecked(bool(self.prefs.get("osnap_perp", False)))
        self.act_os_end.toggled.connect(lambda v: self._set_osnap("end", v))
        self.act_os_mid.toggled.connect(lambda v: self._set_osnap("mid", v))
        self.act_os_cen.toggled.connect(lambda v: self._set_osnap("center", v))
        self.act_os_int.toggled.connect(lambda v: self._set_osnap("intersect", v))
        self.act_os_perp.toggled.connect(lambda v: self._set_osnap("perp", v))
        m_osnap.addAction(self.act_os_end)
        m_osnap.addAction(self.act_os_mid)
        m_osnap.addAction(self.act_os_cen)
        m_osnap.addAction(self.act_os_int)
        m_osnap.addAction(self.act_os_perp)
        # apply initial states to view
        self._set_osnap("end", self.act_os_end.isChecked())
        self._set_osnap("mid", self.act_os_mid.isChecked())
        self._set_osnap("center", self.act_os_cen.isChecked())
        self._set_osnap("intersect", self.act_os_int.isChecked())
        self._set_osnap("perp", self.act_os_perp.isChecked())

        # No toolbars for base feel; reserve top bar for LV CAD items later

        # Status bar Grid controls
        sb = self.statusBar()
        wrap = QWidget()
        lay = QHBoxLayout(wrap)
        lay.setContentsMargins(6, 0, 6, 0)
        lay.setSpacing(10)
        # Grid opacity control
        lay.addWidget(QLabel("Grid"))
        self.slider_grid = QtWidgets.QSlider(Qt.Horizontal)
        self.slider_grid.setMinimum(10)
        self.slider_grid.setMaximum(100)
        self.slider_grid.setFixedWidth(110)
        cur_op = float(self.prefs.get("grid_opacity", 0.25))
        self.slider_grid.setValue(int(max(10, min(100, round(cur_op * 100)))))
        self.lbl_gridp = QLabel(f"{int(self.slider_grid.value())}%")
        lay.addWidget(self.slider_grid)
        lay.addWidget(self.lbl_gridp)
        # Grid size control
        lay.addWidget(QLabel("Size"))
        self.spin_grid_status = QSpinBox()
        self.spin_grid_status.setRange(2, 500)
        self.spin_grid_status.setValue(self.scene.grid_size)
        self.spin_grid_status.setFixedWidth(70)
        lay.addWidget(self.spin_grid_status)
        sb.addPermanentWidget(wrap)

        def _apply_grid_op(val: int):
            op = max(0.10, min(1.00, val / 100.0))
            self.scene.set_grid_style(opacity=op)
            self.prefs["grid_opacity"] = op
            save_prefs(self.prefs)
            self.lbl_gridp.setText(f"{int(val)}%")

        self.slider_grid.valueChanged.connect(_apply_grid_op)
        self.spin_grid_status.valueChanged.connect(self.change_grid_size)

        # Command bar
        cmd_wrap = QWidget()
        cmd_l = QHBoxLayout(cmd_wrap)
        cmd_l.setContentsMargins(6, 0, 6, 0)
        cmd_l.setSpacing(6)
        cmd_l.addWidget(QLabel("Cmd:"))
        self.cmd = QLineEdit()
        self.cmd.setPlaceholderText("Type command (e.g., L, RECT, MOVE)â€¦")
        self.cmd.returnPressed.connect(self._run_command)
        cmd_l.addWidget(self.cmd)
        sb.addPermanentWidget(cmd_wrap, 1)

        # Toolbars removed: keeping top bar clean for LV CAD-specific UI later

        # Left panel (device palette)
        self._build_left_panel()

        # Right dock: Layers & Properties
        self._build_layers_and_props_dock()
        # DXF Layers dock
        self._dxf_layers = {}
        self._build_dxf_layers_dock()

        # Shortcuts
        QtGui.QShortcut(QtGui.QKeySequence("D"), self, activated=self.start_dimension)
        QtGui.QShortcut(QtGui.QKeySequence("Esc"), self, activated=self.cancel_active_tool)
        QtGui.QShortcut(QtGui.QKeySequence("F2"), self, activated=self.fit_view_to_content)

        # Selection change â†’ update Properties
        self.scene.selectionChanged.connect(self._on_selection_changed)

        # Initialize history structures before any tool or placement may push state.
        self.history = []
        self.history_index = -1
        # Push initial state
        try:
            self.push_history()
        except Exception:
            # If push_history depends on other init steps not yet complete,
            # leave the empty history in place; callers will handle gracefully.
            pass
        # Fit view after UI ready
        try:
            QtCore.QTimer.singleShot(0, self.fit_view_to_content)
        except Exception:
            pass

    # ---------- Theme ----------
    def apply_dark_theme(self):
        app = QtWidgets.QApplication.instance()
        pal = app.palette()
        bg = QtGui.QColor(25, 26, 28)
        base = QtGui.QColor(32, 33, 36)
        text = QtGui.QColor(220, 220, 225)
        pal.setColor(QtGui.QPalette.ColorRole.Window, bg)
        pal.setColor(QtGui.QPalette.ColorRole.Base, base)
        pal.setColor(QtGui.QPalette.ColorRole.AlternateBase, QtGui.QColor(38, 39, 43))
        pal.setColor(QtGui.QPalette.ColorRole.Text, text)
        pal.setColor(QtGui.QPalette.ColorRole.WindowText, text)
        pal.setColor(QtGui.QPalette.ColorRole.Button, base)
        pal.setColor(QtGui.QPalette.ColorRole.ButtonText, text)
        pal.setColor(QtGui.QPalette.ColorRole.ToolTipBase, base)
        pal.setColor(QtGui.QPalette.ColorRole.ToolTipText, text)
        pal.setColor(QtGui.QPalette.ColorRole.Highlight, QtGui.QColor(66, 133, 244))
        pal.setColor(QtGui.QPalette.ColorRole.HighlightedText, QtGui.QColor(255, 255, 255))
        app.setPalette(pal)
        self._apply_menu_stylesheet(contrast_boost=False)

    def apply_light_theme(self):
        app = QtWidgets.QApplication.instance()
        pal = app.palette()
        bg = QtGui.QColor(245, 246, 248)
        base = QtGui.QColor(255, 255, 255)
        text = QtGui.QColor(20, 20, 25)
        pal.setColor(QtGui.QPalette.ColorRole.Window, bg)
        pal.setColor(QtGui.QPalette.ColorRole.Base, base)
        pal.setColor(QtGui.QPalette.ColorRole.AlternateBase, QtGui.QColor(240, 240, 245))
        pal.setColor(QtGui.QPalette.ColorRole.Text, text)
        pal.setColor(QtGui.QPalette.ColorRole.WindowText, text)
        pal.setColor(QtGui.QPalette.ColorRole.Button, base)
        pal.setColor(QtGui.QPalette.ColorRole.ButtonText, text)
        pal.setColor(QtGui.QPalette.ColorRole.ToolTipBase, base)
        pal.setColor(QtGui.QPalette.ColorRole.ToolTipText, text)
        pal.setColor(QtGui.QPalette.ColorRole.Highlight, QtGui.QColor(33, 99, 255))
        pal.setColor(QtGui.QPalette.ColorRole.HighlightedText, QtGui.QColor(255, 255, 255))
        app.setPalette(pal)
        self._apply_menu_stylesheet(contrast_boost=False)

    def apply_high_contrast_theme(self):
        app = QtWidgets.QApplication.instance()
        pal = app.palette()
        bg = QtGui.QColor(18, 18, 18)
        base = QtGui.QColor(10, 10, 12)
        text = QtGui.QColor(245, 245, 245)
        pal.setColor(QtGui.QPalette.ColorRole.Window, bg)
        pal.setColor(QtGui.QPalette.ColorRole.Base, base)
        pal.setColor(QtGui.QPalette.ColorRole.AlternateBase, QtGui.QColor(28, 28, 32))
        pal.setColor(QtGui.QPalette.ColorRole.Text, text)
        pal.setColor(QtGui.QPalette.ColorRole.WindowText, text)
        pal.setColor(QtGui.QPalette.ColorRole.Button, QtGui.QColor(26, 26, 30))
        pal.setColor(QtGui.QPalette.ColorRole.ButtonText, text)
        pal.setColor(QtGui.QPalette.ColorRole.ToolTipBase, QtGui.QColor(30, 30, 30))
        pal.setColor(QtGui.QPalette.ColorRole.ToolTipText, QtGui.QColor(255, 255, 255))
        pal.setColor(QtGui.QPalette.ColorRole.Highlight, QtGui.QColor(90, 160, 255))
        pal.setColor(QtGui.QPalette.ColorRole.HighlightedText, QtGui.QColor(0, 0, 0))
        app.setPalette(pal)
        self._apply_menu_stylesheet(contrast_boost=True)

    def set_theme(self, name: str):
        name = (name or "dark").lower()
        if name == "light":
            self.apply_light_theme()
        elif name in ("hc", "high", "high_contrast", "high-contrast"):
            self.apply_high_contrast_theme()
        else:
            self.apply_dark_theme()
        self.prefs["theme"] = name
        save_prefs(self.prefs)

    def _apply_menu_stylesheet(self, contrast_boost: bool):
        if contrast_boost:
            ss = """
            QMenuBar { background: #0f1113; color: #eaeaea; }
            QMenuBar::item:selected { background: #2f61ff; color: #ffffff; }
            QMenu { background: #14161a; color: #f0f0f0; border: 1px solid #364049; }
            QMenu::item:selected { background: #2f61ff; color: #ffffff; }
            QToolBar { background: #0f1113; border-bottom: 1px solid #364049; }
            QStatusBar { background: #0f1113; color: #cfd8e3; }
            """
        else:
            ss = """
            QMenuBar { background: transparent; }
            QMenu { border: 1px solid rgba(0,0,0,40); }
            """
        self.setStyleSheet(ss)

# (file intentionally truncated in backup for readability; original full file preserved in repo)
